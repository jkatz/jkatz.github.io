<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Postgres on Jonathan Katz</title><link>https://jkatz.github.io/post/postgres/</link><description>Recent content in Posts on Postgres on Jonathan Katz</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 10 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://jkatz.github.io/post/postgres/index.xml" rel="self" type="application/rss+xml"/><item><title>An early look at HNSW performance with pgvector</title><link>https://jkatz.github.io/post/postgres/pgvector-hnsw-performance/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://jkatz.github.io/post/postgres/pgvector-hnsw-performance/</guid><description>&lt;p>(Disclosure: I have been contributing to pgvector, though I did not work on the HNSW implementation outside of testing).&lt;/p>
&lt;p>The surge of usage of AI/ML systems, particularly around generative AI, has also lead to a surge in requirements to store its output, &lt;a href="https://jkatz.github.io/post/postgres/vectors-json-postgresql/">vector data&lt;/a>, in databases. For more details on this, please read my previous post on how &lt;a href="https://jkatz.github.io/post/postgres/vectors-json-postgresql/">vectors are the new JSON&lt;/a>, as they are the &lt;em>lingua franca&lt;/em> in AI/ML systems.&lt;/p>
&lt;p>&lt;a href="https://github.com/pgvector/pgvector">pgvector&lt;/a> is an open source extension that lets you store vector data in &lt;a href="https://www.postgresql.org/">PostgreSQL&lt;/a> and perform &lt;a href="https://en.wikipedia.org/wiki/Nearest_neighbor_search">nearest neighbor&lt;/a> (K-NN) searches to find similar results. This includes support for exact nearest neighbor searches via scanning an entire table, and &amp;ldquo;approximate nearest neighbor&amp;rdquo; (ANN) via indexing. ANN indexes let you perform faster searches over your vector data, but with a tradeoff of &lt;a href="https://en.wikipedia.org/wiki/Precision_and_recall">recall&lt;/a>&amp;quot;, where &amp;ldquo;recall&amp;rdquo; is the percentage of relevant results returned. A typically K-NN query looks something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">embedding&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;-&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">query_vector&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Prior to the v0.5.0, pgvector supported one indexing method: &lt;code>ivfflat&lt;/code>. To build an index, the &lt;code>ivfflat&lt;/code> algorithm samples (looks over a subset) your vector data, uses a k-means algorithms to define a number of &lt;code>lists&lt;/code> (or &amp;ldquo;centers&amp;rdquo;), and indexes the vectors in the table by assigning each of them to its closest &amp;ldquo;list&amp;rdquo; by distance (e.g. &lt;a href="https://en.wikipedia.org/wiki/Euclidean_distance">L2 distance&lt;/a>, &lt;a href="https://en.wikipedia.org/wiki/Cosine_similarity">cosine distance&lt;/a>). When querying your vector data, you can select how many lists to check using the &lt;code>ivfflat.probes&lt;/code> config parameter. Setting a higher value of &lt;code>ivfflat.probes&lt;/code> increases recall but can decrease query performance.&lt;/p>
&lt;p>The &lt;code>ivfflat&lt;/code> method has many advantages, including its simplicity to use, speed in building the index, and ability to use it as a &amp;ldquo;&lt;a href="https://github.com/facebookresearch/faiss/wiki/Indexing-1G-vectors">coarse quantizer&lt;/a>&amp;rdquo; when indexing over large datasets. However, other algorithms, including &amp;ldquo;&lt;a href="https://arxiv.org/ftp/arxiv/papers/1603/1603.09320.pdf">hierarchical navigable small worlds&lt;/a>&amp;rdquo; &lt;a href="https://arxiv.org/ftp/arxiv/papers/1603/1603.09320.pdf">HNSW&lt;/a>, provide other methodologies for improving the performance / recall ratio of similarity searches. Many HNSW implementations have demonstrated &lt;a href="https://github.com/erikbern/ann-benchmarks">favorable performance/recall tradeoffs&lt;/a>, but usually this comes at a cost of index building time.&lt;/p>
&lt;p>Starting with v0.5.0, pgvector has support for &lt;code>hnsw&lt;/code> thanks to &lt;a href="https://github.com/ankane">Andrew Kane&lt;/a>. Much like its &lt;code>ivfflat&lt;/code> implementation, pgvector users can perform all the expected data modification operations with an &lt;code>hnsw&lt;/code> including insert/update/delete (yes &amp;ndash; &lt;code>hnsw&lt;/code> in pgvector supports update and delete!). The HNSW algorithm is designed for adding data iteratively and does not require to index an existing data set to achieve better recall. For more information on how HNSW works, please read the &lt;a href="https://arxiv.org/ftp/arxiv/papers/1603/1603.09320.pdf">original research paper&lt;/a>.&lt;/p>
&lt;p>While v0.5.0 is not out at the time of this blog post, I wanted to provide an early look at HNSW in pgvector given the excitement for this feature. The rest of this blog post covers how I ran the experiment and some analysis.&lt;/p>
&lt;h2 id="testing-performance--recall-of-the-pgvector-hnsw-implementation">Testing performance / recall of the pgvector HNSW implementation&lt;/h2>
&lt;p>When testing ANN indexing algorithms, you cannot look only at query performance. You may have an indexing algorithm that returns results quickly, but if the recall of those results is low, you may not be delivering the best possible results to your users. This is why it&amp;rsquo;s important to measure recall alongside performance to understand how you can optimize your index for both speed and relevance of your search results.&lt;/p>
&lt;p>It&amp;rsquo;s also important to see how long it takes to build an index. This is a practical consideration for running vector storage systems in production, as different implementations may need to take locks on the primary table that prevent changes during a build. PostgreSQL offers the ability to both &lt;a href="https://www.postgresql.org/docs/current/sql-createindex.html">create indexes concurrently&lt;/a> and to &lt;a href="https://www.postgresql.org/docs/current/sql-reindex.html">reindex concurrently&lt;/a>, which lets you continue to make changes to data in a table without blocking writes.&lt;/p>
&lt;p>Here&amp;rsquo;s a summary of different performance attributes that I analyzed in this experiment:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Performance / Recall ratio&lt;/strong>: As mentioned, in ANN indexes, you must look at both performance AND recall to make an informed judgement on how well the index worked.&lt;/li>
&lt;li>&lt;strong>Index build time&lt;/strong>: How long does it take to build the index? This affects both maintaining the index and how quickly you can add additional data.&lt;/li>
&lt;li>&lt;strong>Index size&lt;/strong>: How much space does the index take up on disk? (This lead to a &lt;a href="https://github.com/erikbern/ann-benchmarks/pull/456">small patch in the ANN Benchmark suite&lt;/a>, and a major kudos to their quick review!)&lt;/li>
&lt;/ul>
&lt;p>For this experiment, I focused entirely on optimizing my environment for performance, particularly around keeping the workload in memory. I used an &lt;a href="https://aws.amazon.com/ec2/instance-types/r7g/">r7gd.16xlarge&lt;/a> (64 vCPU, 512GM RAM) instance with my PostgreSQL data directory installed directly on the local NVMe. I used &lt;a href="https://www.postgresql.org/about/news/postgresql-15-released-2526/">PostgreSQL 15.3&lt;/a> and ran all of the tests locally, i.e. the benchmarking suite connected directly to the PostgreSQL instance over a local socket. I used the &lt;a href="https://github.com/erikbern/ann-benchmarks">ANN Benchmark&lt;/a> test framework (more on this below), ran one test at a time, and note that the framework runs a single query at a time.&lt;/p>
&lt;p>For test data, I used the following known data sets from the &lt;a href="https://github.com/erikbern/ann-benchmarks">ANN Benchmark&lt;/a> suite. In the parenthesis, I use (data set size, vector dimensions):&lt;/p>
&lt;ul>
&lt;li>mnist-784-euclidean (60K, 784-dim)&lt;/li>
&lt;li>sift-128-euclidean (1M, 128-dim)&lt;/li>
&lt;li>gist-960-euclidean (1M, 960-dim)&lt;/li>
&lt;li>dbpedia-openai-1000k-angular (1M, 1536-dim)&lt;/li>
&lt;/ul>
&lt;p>Running these with the ANN Benchmark testing suite required &lt;a href="https://gist.github.com/jkatz/28a2f174effa987713926ce37bb5d304">creating new modules&lt;/a> for the HNSW implementation for pgvector where I did the following:&lt;/p>
&lt;ul>
&lt;li>Store the vectors in the table using &lt;code>PLAIN&lt;/code> storage, i.e. the data was not &lt;a href="https://www.postgresql.org/docs/current/storage-toast.html">TOASTed&lt;/a> but stored inline.&lt;/li>
&lt;li>Built the index (and measured total build time + index size)&lt;/li>
&lt;li>&lt;a href="https://www.postgresql.org/docs/current/pgprewarm.html">Prewarmed the shared buffer cache&lt;/a> to start with the table and index data in memory.&lt;/li>
&lt;/ul>
&lt;p>For PostgreSQL configuration, I had the following settings, with a focus on keeping the workload in memory:&lt;/p>
&lt;ul>
&lt;li>&lt;code>shared_buffers&lt;/code>: 128GB&lt;/li>
&lt;li>&lt;code>effective_cache_size&lt;/code>: 256GB&lt;/li>
&lt;li>&lt;code>work_mem&lt;/code>: 4GB&lt;/li>
&lt;li>&lt;code>maintenance_work_mem&lt;/code>: 64GB&lt;/li>
&lt;li>&lt;code>max_wal_size&lt;/code>: 20GB&lt;/li>
&lt;li>&lt;code>wal_compression&lt;/code>: zstd&lt;/li>
&lt;li>&lt;code>checkpoint_timeout&lt;/code>: 2h&lt;/li>
&lt;li>&lt;code>jit&lt;/code>: off&lt;/li>
&lt;/ul>
&lt;p>Additionally, as parallelism in the index building process for &lt;code>ivfflat&lt;/code> is also a pgvector v0.5.0, I&amp;rsquo;ll note the following parallelism settings:&lt;/p>
&lt;ul>
&lt;li>&lt;code>max_worker_processes&lt;/code>: 128&lt;/li>
&lt;li>&lt;code>max_parallel_workers&lt;/code>: 64&lt;/li>
&lt;li>&lt;code>max_parallel_maintenance_workers&lt;/code>: 64&lt;/li>
&lt;li>&lt;code>max_parallel_workers_per_gather&lt;/code>: 64&lt;/li>
&lt;li>&lt;code>min_parallel_table_scan_size&lt;/code>: 1&lt;/li>
&lt;/ul>
&lt;p>Next, we need to consider what parameters we need to test and vary for testing the HNSW implementation. hnswlib as an explanation for &lt;a href="https://github.com/nmslib/hnswlib/blob/master/ALGO_PARAMS.md">how the different parameters&lt;/a> work, with my attempt to summarize them below:&lt;/p>
&lt;ul>
&lt;li>&lt;code>M&lt;/code>: An index building parameter that indicates how many bidirectional links (or paths) exist between each indexed element. This is a key piece in how we search over an HNSW index.&lt;/li>
&lt;li>&lt;code>ef_construction&lt;/code>: An index building parameter that indicates how many nearest neighbors to check while adding an element to the index.&lt;/li>
&lt;li>&lt;code>ef_search&lt;/code>: This is a search parameter that indicates the number of nearest neighbors to keep in a &amp;ldquo;dynamic list&amp;rdquo; while keeping the search. A large value can improve recall, usually with a tradeoff in performance. You need &lt;code>ef_search&lt;/code> be at least as big as your &lt;code>LIMIT&lt;/code> value.&lt;/li>
&lt;/ul>
&lt;p>To set up the actual code to test, given this is a moving target, I picked pgvector at commit &lt;a href="https://github.com/pgvector/pgvector/commit/600ca5a7">600ca5a7&lt;/a> to test both its ivfflat and HNSW implementation. To have an additional implementation to compare against, I also selected pg_embedding, another recent HNSW implementation targeted for PostgreSQL. In summary, I tested each implementation at the following commits, which we the latest when I ran these tests:&lt;/p>
&lt;ul>
&lt;li>&lt;code>pgvector&lt;/code> (ivfflat): &lt;a href="https://github.com/pgvector/pgvector/commit/600ca5a7">600ca5a7&lt;/a>&lt;/li>
&lt;li>&lt;code>pgvector_hnsw&lt;/code> (hnsw) &lt;a href="https://github.com/pgvector/pgvector/commit/600ca5a7">600ca5a7&lt;/a>&lt;/li>
&lt;li>&lt;code>pg_embedding&lt;/code> (hnsw) &lt;a href="https://github.com/pgvector/pgvector/commit/e1db3a5a">e1db3a5a&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Finally, we need test parameters. For &lt;code>ivfflat&lt;/code>, I used the &lt;a href="https://github.com/erikbern/ann-benchmarks/blob/main/ann_benchmarks/algorithms/pgvector/config.yml">existing configuration&lt;/a> in ANN Benchmark that varies lists and probes. For the HNSW algorithms, I took the test parameters from the mirrored test parameters from the other HNSW implementations, but only test a subset of construction parameters.&lt;/p>
&lt;ul>
&lt;li>Construction
&lt;ul>
&lt;li>M=12, ef_construction=60&lt;/li>
&lt;li>M=16, ef_construction=40&lt;/li>
&lt;li>M=24, ef_construction=40&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Search: ef_search=10, ef_search=20, ef_search=40, ef_search=80, ef_search=120, ef_search=200, ef_search=400, ef_search=600, ef_search=800,&lt;/li>
&lt;/ul>
&lt;p>(I do want to personally understand the impact of the construction parameters more, and will be running tests in the future that dive further into the variations. However, running the test suite does take time!)&lt;/p>
&lt;p>Running these with the ANN Benchmark suite required creating &lt;a href="https://gist.github.com/jkatz/28a2f174effa987713926ce37bb5d304">new modules&lt;/a>. Credit to &lt;a href="https://github.com/pashkinelfe">Pavel Borisov&lt;/a> for most of the work on the pg_embedding HNSW test. I anticipate portions of this work to be proposed for the upstream ANN Benchmark project once HNSW is released for pgvector.&lt;/p>
&lt;p>So, how did the tests go?&lt;/p>
&lt;h2 id="results-and-analysis">Results and Analysis&lt;/h2>
&lt;p>The first thing to emphasize is that these tests were conducted at a specific point in time in all the projects involved. The results today may not match the results tomorrow, but they provide a directional snapshot of where things stand today. I also wanted to use this as an exercise to highlight the tradeoffs on where you may want to use &lt;code>ivfflat&lt;/code> vs. &lt;code>hnsw&lt;/code>, as both indexes have utility.&lt;/p>
&lt;p>For the rest of this section, we&amp;rsquo;ll look at the tests in each data set, and explore:&lt;/p>
&lt;ul>
&lt;li>The query performance / recall ratio&lt;/li>
&lt;li>Index build time&lt;/li>
&lt;li>Index size&lt;/li>
&lt;/ul>
&lt;h3 id="mnist-784-euclidean-60k-784-dim">mnist-784-euclidean (60K, 784-dim)&lt;/h3>
&lt;p>This is my &amp;ldquo;sanity check&amp;rdquo; data set: it&amp;rsquo;s not too large (you can run tests quickly), but it also has higher dimensionality vector (you can see some of the oddities that come with higher dimensions). I have used it to successfully hunt down obvious performance regressions.&lt;/p>
&lt;h4 id="pgvector-ivfflat">pgvector (ivfflat)&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Parameters&lt;/th>
&lt;th>Build time (min)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>lists=100&lt;/td>
&lt;td>0.19&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>lists=200&lt;/td>
&lt;td>0.20&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>lists=400&lt;/td>
&lt;td>0.24&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>lists=1000&lt;/td>
&lt;td>0.54&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>lists=2000&lt;/td>
&lt;td>0.91&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>lists=4000&lt;/td>
&lt;td>1.56&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>NOTE:&lt;/strong> I did not get the index size as I did not run the test with &lt;a href="https://github.com/erikbern/ann-benchmarks/pull/456">this patch&lt;/a> in place. However, the index size is roughly the same size as the vector column indexed in the table, plus overhead with the lists&lt;/p>
&lt;h4 id="pgvector_hnsw-hnsw">pgvector_hnsw (hnsw)&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Parameters&lt;/th>
&lt;th>Build time (min)&lt;/th>
&lt;th>Index size (MB)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>M=12,ef_construction=60&lt;/td>
&lt;td>0.87&lt;/td>
&lt;td>234&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M=16,ef_construction=40&lt;/td>
&lt;td>1.02&lt;/td>
&lt;td>234&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M=24,ef_construction=40&lt;/td>
&lt;td>1.45&lt;/td>
&lt;td>234&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="pg_embedding_hnsw-hnsw">pg_embedding_hnsw (hnsw)&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Parameters&lt;/th>
&lt;th>Build time (min)&lt;/th>
&lt;th>Index size (MB)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>M=12,ef_construction=60&lt;/td>
&lt;td>1.28&lt;/td>
&lt;td>234&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M=16,ef_construction=40&lt;/td>
&lt;td>1.16&lt;/td>
&lt;td>234&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M=24,ef_construction=40&lt;/td>
&lt;td>1.16&lt;/td>
&lt;td>234&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;img src="https://jkatz.github.io/images/mnist-784-euclidean.png" alt="mnist-784-euclidean.png">&lt;/p>
&lt;p>Analysis:&lt;/p>
&lt;ul>
&lt;li>This is the case-in-point why you must measure both performance and recall. From a pure performance standpoint, pgvector&amp;rsquo;s &lt;code>ivfflat&lt;/code> index does have higher QPS (though not by much compared to pgvector&amp;rsquo;s &lt;code>hnsw&lt;/code>), but at a great expense with recall.&lt;/li>
&lt;li>This is a small dataset, so we can&amp;rsquo;t draw too many conclusions. However, the results show that pgvector&amp;rsquo;s &lt;code>hnsw&lt;/code> implementation does have very strong performance / recall characteristics on this smaller data set.&lt;/li>
&lt;/ul>
&lt;h3 id="sift-128-euclidean-1m-128-dim">sift-128-euclidean (1M, 128-dim)&lt;/h3>
&lt;p>This is another data set I like to run against earlier on in my testing, as it&amp;rsquo;s much larger (1 million vectors) but has lower dimensionality, so testing is generally faster. You&amp;rsquo;ll also start to see the effect of indexing these vectors at scale. Additionally, because this is lower dimensionality (I still find it amusing that 128 dimensions is &amp;ldquo;low&amp;rdquo;), you will see less of the higher dimensionality quirks in your searches.&lt;/p>
&lt;h4 id="pgvector-ivfflat-1">pgvector (ivfflat)&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Parameters&lt;/th>
&lt;th>Build time (min)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>lists=100&lt;/td>
&lt;td>0.61&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>lists=200&lt;/td>
&lt;td>0.61&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>lists=400&lt;/td>
&lt;td>0.63&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>lists=1000&lt;/td>
&lt;td>0.75&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>lists=2000&lt;/td>
&lt;td>1.35&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>lists=4000&lt;/td>
&lt;td>3.58&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>NOTE:&lt;/strong> I did not get the index size as I did not run the test with &lt;a href="https://github.com/erikbern/ann-benchmarks/pull/456">this patch&lt;/a> in place. However, the index size is roughly the same size as the vector column indexed in the table, plus overhead with the lists&lt;/p>
&lt;h4 id="pgvector_hnsw-hnsw-1">pgvector_hnsw (hnsw)&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Parameters&lt;/th>
&lt;th>Build time (min)&lt;/th>
&lt;th>Index size (MB)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>M=12,ef_construction=60&lt;/td>
&lt;td>12.20&lt;/td>
&lt;td>769&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M=16,ef_construction=40&lt;/td>
&lt;td>15.91&lt;/td>
&lt;td>782&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M=24,ef_construction=40&lt;/td>
&lt;td>25.23&lt;/td>
&lt;td>902&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="pg_embedding_hnsw-hnsw-1">pg_embedding_hnsw (hnsw)&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Parameters&lt;/th>
&lt;th>Build time (min)&lt;/th>
&lt;th>Index size (MB)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>M=12,ef_construction=60&lt;/td>
&lt;td>14.08&lt;/td>
&lt;td>651&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M=16,ef_construction=40&lt;/td>
&lt;td>11.27&lt;/td>
&lt;td>651&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M=24,ef_construction=40&lt;/td>
&lt;td>11.88&lt;/td>
&lt;td>710&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;img src="https://jkatz.github.io/images/sift-128-euclidean.png" alt="sift-128-euclidean.png">&lt;/p>
&lt;p>Analysis:&lt;/p>
&lt;ul>
&lt;li>Again, it&amp;rsquo;s crucial to look at both performance and recall. &lt;code>ivfflat&lt;/code> has high throughput, but on this test, it underperforms both &lt;code>hnsw&lt;/code> implementations when looking at the same relative recall.&lt;/li>
&lt;li>pgvector&amp;rsquo;s &lt;code>hnsw&lt;/code> implementation achieves better performance and recall compared to the other two algorithms on this data set, though they all trend towards similar performance when increasing the search area.&lt;/li>
&lt;li>&lt;code>ivfflat&lt;/code> is incredibly quick for building indexes (and note this leverages the parallel build feature in v0.5.0).&lt;/li>
&lt;li>We can start to see some differences in index build time and size between the two HNSW implementations. On the surface, it appears increasing &lt;code>ef_construction&lt;/code> impacts pg_embedding&amp;rsquo;s HNSW implementation, whereas for pgvector it&amp;rsquo;s in increasing &lt;code>M&lt;/code>, but this would require a deeper investigation on varying the parameters to draw additional conclusions.&lt;/li>
&lt;/ul>
&lt;h3 id="gist-960-euclidean-1m-960-dim">gist-960-euclidean (1M, 960-dim)&lt;/h3>
&lt;p>I like this dataset because this is where you start to see different implementations sweat. It has a nice size (1M vectors) and a higher dimensionality (960), so your index building and lookups are going to need to do more work.&lt;/p>
&lt;p>I did not include the &lt;code>ivfflat&lt;/code> implementation in this test due to time so I could prioritize the final test.&lt;/p>
&lt;h4 id="pgvector_hnsw-hnsw-2">pgvector_hnsw (hnsw)&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Parameters&lt;/th>
&lt;th>Build time (min)&lt;/th>
&lt;th>Index size (MB)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>M=12,ef_construction=60&lt;/td>
&lt;td>41.37&lt;/td>
&lt;td>4,316&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M=16,ef_construction=40&lt;/td>
&lt;td>60.20&lt;/td>
&lt;td>7,688&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M=24,ef_construction=40&lt;/td>
&lt;td>112.04&lt;/td>
&lt;td>7,812&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="pg_embedding_hnsw-hnsw-2">pg_embedding_hnsw (hnsw)&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Parameters&lt;/th>
&lt;th>Build time (min)&lt;/th>
&lt;th>Index size (MB)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>M=12,ef_construction=60&lt;/td>
&lt;td>50.48&lt;/td>
&lt;td>3,906&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M=16,ef_construction=40&lt;/td>
&lt;td>45.77&lt;/td>
&lt;td>3,906&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M=24,ef_construction=40&lt;/td>
&lt;td>49.01&lt;/td>
&lt;td>3,906&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;img src="https://jkatz.github.io/images/gist-960-euclidean.png" alt="gist-960-euclidean.png">&lt;/p>
&lt;p>Analysis:&lt;/p>
&lt;ul>
&lt;li>From both a performance/recall standpoint, pgvector&amp;rsquo;s HNSW implementation outperforms pg_embedding on this data set, though the gap closes for higher values of &lt;code>ef_search&lt;/code>.&lt;/li>
&lt;li>pg_embedding has smaller indexes on this build, and pgvector&amp;rsquo;s index build time increased with larger values of &lt;code>M&lt;/code> whereas pg_embedding stayed flat. There&amp;rsquo;s likely wor&lt;/li>
&lt;/ul>
&lt;h3 id="dbpedia-openai-1000k-angular-1m-1536-dim">dbpedia-openai-1000k-angular (1M, 1536-dim)&lt;/h3>
&lt;p>This is the dataset-du-jour that provides vector data that is similar to what you would find in an LLM, in this case, 1536 dimensional vectors. Unlike the other examples above, this data set uses a cosine distance operation.&lt;/p>
&lt;h4 id="pgvector-ivfflat-2">pgvector (ivfflat)&lt;/h4>
&lt;p>I only completed two runs, and would like to re-run it again during the next point-in-time evaluation of the algorithms.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Parameters&lt;/th>
&lt;th>Build time (min)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>lists=200&lt;/td>
&lt;td>16.55&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>lists=400&lt;/td>
&lt;td>16.68&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>NOTE:&lt;/strong> I did not get the index size as I did not run the test with &lt;a href="https://github.com/erikbern/ann-benchmarks/pull/456">this patch&lt;/a> in place. However, the index size is roughly the same size as the vector column indexed in the table, plus overhead with the lists&lt;/p>
&lt;h4 id="pgvector_hnsw-hnsw-3">pgvector_hnsw (hnsw)&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Parameters&lt;/th>
&lt;th>Build time (min)&lt;/th>
&lt;th>Index size (MB)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>M=12,ef_construction=60&lt;/td>
&lt;td>49.40&lt;/td>
&lt;td>7,734&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M=16,ef_construction=40&lt;/td>
&lt;td>60.10&lt;/td>
&lt;td>7,734&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M=24,ef_construction=40&lt;/td>
&lt;td>82.35&lt;/td>
&lt;td>7,734&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="pg_embedding_hnsw-hnsw-3">pg_embedding_hnsw (hnsw)&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Parameters&lt;/th>
&lt;th>Build time (min)&lt;/th>
&lt;th>Index size (MB)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>M=12,ef_construction=60&lt;/td>
&lt;td>72.22&lt;/td>
&lt;td>7,734&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M=16,ef_construction=40&lt;/td>
&lt;td>67.06&lt;/td>
&lt;td>7,734&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M=24,ef_construction=40&lt;/td>
&lt;td>68.56&lt;/td>
&lt;td>7,734&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;img src="https://jkatz.github.io/images/dbpedia-openai-1000k-angular.png" alt="dbpedia-openai-1000k-angular.png">&lt;/p>
&lt;p>Analysis:&lt;/p>
&lt;ul>
&lt;li>pgvector&amp;rsquo;s HNSW implementation has better performance/recall ratio than the other algorithms by a fairly wide margin.&lt;/li>
&lt;li>You can&amp;rsquo;t beat ivfflat in index building times: you can understand why it&amp;rsquo;s popular as a coarse quantizer. The index building times between pgvector&amp;rsquo;s HNSW and pg_embedding&amp;rsquo;s HNSW are more comparable here, which may be due to the implementation of the cosine distance functions.&lt;/li>
&lt;li>I&amp;rsquo;m surprised the indexes are the same size; I need to drill into that more.&lt;/li>
&lt;/ul>
&lt;h2 id="whats-next">What&amp;rsquo;s next?&lt;/h2>
&lt;p>As mentioned, this is just a first look at pgvector&amp;rsquo;s HNSW implementation at a specific commit (&lt;a href="https://github.com/pgvector/pgvector/commit/600ca5a7">600ca5a7&lt;/a>). Even since I ran the tests, there have been additional commits that iterate on its HNSW implementation. I&amp;rsquo;m personally excited to see where things land for the v0.5.0.&lt;/p>
&lt;p>This is also to serve as a lesson that this is a fast moving space, not just for storing vector data in PostgreSQL, but in general. As I mentioned in &lt;a href="https://jkatz.github.io/post/postgres/vectors-json-postgresql/">Vectors are the new JSON in PostgreSQL&lt;/a>, while the vector itself is very old, modern processing research is still relatively new (~20 years) and we&amp;rsquo;re still finding new innovations in this space. There are still some proven research techniques that pgvector can adopt that will help in all areas: performance/recall, index sizes, and build times.&lt;/p>
&lt;p>I think PostgreSQL will continue to be in a place where folks want to use it as a vector database, not just because it&amp;rsquo;s convenient, but because it can handle the demands of high performance workloads. The addition of the HNSW algorithm to the PostgreSQL extension ecosystem is one step, though a big step, in continuing to help people successfully store and search over vector data in PostgreSQL.&lt;/p></description></item><item><title>Vectors are the new JSON in PostgreSQL</title><link>https://jkatz.github.io/post/postgres/vectors-json-postgresql/</link><pubDate>Mon, 26 Jun 2023 00:00:00 +0000</pubDate><guid>https://jkatz.github.io/post/postgres/vectors-json-postgresql/</guid><description>&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Row_and_column_vectors">Vectors&lt;/a> are the new &lt;a href="https://en.wikipedia.org/wiki/JSON">JSON&lt;/a>.&lt;/p>
&lt;p>That in itself is an interesting statement, given vectors are a well-studied mathematical structure, and JSON is a data interchange format. And yet in the world of data storage and retrieval, both of these data representations have become the &lt;a href="https://en.wikipedia.org/wiki/Lingua_franca">lingua franca&lt;/a> of their domains and are either essential, or soon-to-be-essential, ingredients in modern application development. And if current trends continue (I think they will), vectors will be as crucial as JSON is for building applications.&lt;/p>
&lt;p>Generative AI and all the buzz around it has caused developers to look for convenient ways to store and run queries against the outputs of these systems, with &lt;a href="https://www.postgresql.org/">PostgreSQL&lt;/a> being a natural choice for a lot of reasons. But even with the hype around generative AI, this is not a new data pattern. Vectors, as a mathematical concept, have been around for hundreds of years. Machine learning has over a half-century worth of research. The &lt;a href="https://www.postgresql.org/docs/current/arrays.html">array&lt;/a> &amp;ndash; the fundamental data structure for a vector &amp;ndash; is taught in most introductory computer science classes. Even PostgreSQL has had support for vector operations for over 20 years (more on that later)!&lt;/p>
&lt;p>So, what is new? It&amp;rsquo;s the &lt;em>accessibility&lt;/em> of these AI/ML algorithms and how easy it is to represent some &amp;ldquo;real world&amp;rdquo; structure (text, images, video) as a vector and store it for some future use by an application. And again, while folks may point to the fact it&amp;rsquo;s not new to store the output of these systems (&amp;ldquo;embeddings&amp;rdquo;) in data storage systems, the emergent pattern is the &lt;em>accessibility&lt;/em> of being able to query and return this data in near real-time in almost any application.&lt;/p>
&lt;p>What does this have to do with &lt;a href="https://www.postgresql.org/">PostgreSQL&lt;/a>? Everything! Efficient storage and retrieval of a data type used in a common pattern greatly simplifies app development, lets people to keep their related data in the same place, and can work with existing tooling. We saw this with JSON over 10 years ago, and now we&amp;rsquo;re seeing this with vector data.&lt;/p>
&lt;p>To understand why vectors are the new JSON, let&amp;rsquo;s rewind and look back at what happened as JSON emerged as the de facto data type for web communications.&lt;/p>
&lt;h2 id="a-very-brief-history-of-json-in-postgresql">A very brief history of JSON in PostgreSQL&lt;/h2>
&lt;p>Back during the &amp;ldquo;rise of JSON&amp;rdquo; I was very much still an app developer. The systems I was building either emitted JSON data to the frontend so that it could complete some sort of action (e.g. rendering an updatable widget) or working with a &amp;ldquo;modern&amp;rdquo; API that returned its data in JSON format. What was nice about JSON was its simplicity (very easy to both read and manipulate), yet its relative expressiveness for a data interchange format. There are some things I would have loved to see in JSON &amp;ndash; skewing towards the database-side, I&amp;rsquo;m definitely a fan of having schemas &amp;ndash; but JSON did simplify communicating between systems efficiently, both from a development and operations standpoint.&lt;/p>
&lt;p>While JSON was meant first and foremost to be an interchange format, people did ask &amp;ldquo;well, why can&amp;rsquo;t I just store and query this natively?&amp;rdquo; This lead to the emergence of specialized data storage systems that let you store and query JSON documents. While I had tried out a few different ad hoc JSON storage systems for a very specific problem, I wasn&amp;rsquo;t sure if I wanted to bring them into my application stack due to performance and maintainability reasons (I won&amp;rsquo;t name names, as I did this analysis well over a decade ago and a lot has changed). This lead to the question &amp;ndash; is it possible store &lt;a href="https://www.postgresql.org/docs/current/datatype-json.html">JSON data in PostgreSQL&lt;/a>.&lt;/p>
&lt;p>I remember going to PostgreSQL events eagerly awaiting what updates there were on PostgreSQL-native support for storage and retrieval of JSON documents. I remember the excitement of &lt;a href="https://www.postgresql.org/about/news/postgresql-92-released-1415/">PostgreSQL 9.2 adding the text-based JSON type&lt;/a>. The initial support for JSON in PostgreSQL validated that the content you were storing was valid JSON, and came with a few functions and operators that helped you extract data contained within the document. There was no native indexing support, but you could build &lt;a href="https://www.postgresql.org/docs/current/indexes-expressional.html">expression indexes&lt;/a> if you planned to frequently query a key within the document.&lt;/p>
&lt;p>This initial JSON support in PostgreSQL helped solve several problems for me, specifically, snapshotting the state of several tables in my database, and logging output from APIs I interfaced with. The initial text-based JSON data type did not have much in the way of search capabilities: it was possible to build &lt;a href="https://www.postgresql.org/docs/current/indexes-expressional.html">expression indexes&lt;/a> to query on a particular key in a JSON document, but pragmatically I would store that key in a column next to the JSON document.&lt;/p>
&lt;p>There&amp;rsquo;s a key element in here: the initial support for JSON had limited utility as a &amp;ldquo;JSON database.&amp;rdquo; Yes, we could now store JSON, and we had some limited querying abilities for it, and it was clear it needed more work to compete with the functionality of ad hoc JSON databases. However, PostgreSQL was still &lt;em>good enough&lt;/em> for many of these use-cases, and in part developers were okay with these limitations so long as they could use the text-based JSON data type with their existing application infrastructure. PostgreSQL was also the first relational database to add support for JSON, setting a trend that ultimately lead to the adoption of JSON in the SQL standard.&lt;/p>
&lt;p>However, the viability of PostgreSQL as a &amp;ldquo;JSON database&amp;rdquo; changed with the &lt;a href="https://www.postgresql.org/about/news/postgresql-94-increases-flexibility-scalability-and-performance-1557/">release of PostgreSQL 9.4&lt;/a>. This release added &lt;code>JSONB&lt;/code>, a binary representation of the JSON data type, but came with the ability to use &lt;a href="https://www.postgresql.org/docs/current/datatype-json.html#JSON-INDEXING">GIN indexing&lt;/a> to search on arbitrary data with JSON documents. From a performance standpoint, this put PostgreSQL on par with JSON databases, while still providing all the other benefits of keeping data in a relational database. While it took a few years, PostgreSQL was able to adapt and evolve to support the workloads of applications.&lt;/p>
&lt;p>Support for JSON in PostgreSQL has continued to evolve and improve through the years, and no doubt will continue to do so as PostgreSQL continues to implement and adopt SQL/JSON. I&amp;rsquo;ve talked to PostgreSQL users who use its JSON support to store tens of &lt;em>terabytes&lt;/em> of JSON documents within a PostgreSQL database &amp;ndash; and they have positive feedback on the experience!&lt;/p>
&lt;p>The key part of this story is that developers were willing to bet on PostgreSQL to have a competitive JSON storage system, and worked with its initial limitations until there was more robust support. Which brings us to vectors.&lt;/p>
&lt;h2 id="the-rise-of-the-vector-a-new-kind-of-json">The rise of the vector: &amp;ldquo;a new kind of JSON&amp;rdquo;&lt;/h2>
&lt;p>Vectors are not new, but they&amp;rsquo;re having a surge in popularity these days. As mentioned earlier, this is due to the newfound accessibility of AI/ML systems, and that the output of these systems are vectors. A common use-case is to build a model on stored data (text, sound, video), convert it to vector format, and then use it for &amp;ldquo;&lt;a href="https://en.wikipedia.org/wiki/Semantic_search">semantic search&lt;/a>.&amp;rdquo; In this case, semantic search is performed when you take a new input, convert it to its corresponding vector, and find the most similar results in the database. Similarity is found using a &lt;a href="https://en.wikipedia.org/wiki/Distance">distance function&lt;/a>, such as &lt;a href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidean&lt;/a> or &lt;a href="https://en.wikipedia.org/wiki/Cosine_similarity">cosine distance&lt;/a>, and the results are often capped at the &amp;ldquo;&lt;a href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm">&lt;strong>k&lt;/strong> nearest neighbors&lt;/a>&amp;rdquo; (K-NN), or &lt;strong>k&lt;/strong> most similar objects. It can take a lot of time to encode the &amp;ldquo;training set&amp;rdquo; of vectors, so it makes sense to &amp;ldquo;cache&amp;rdquo; them in a permanent data storage system, such as a database, and perform K-NN queries there. Having a set of vectors that are ready to be queried for semantic searches makes a generally better experience for users, which has given rise to the notion of needing a &amp;ldquo;vector database.&amp;rdquo;&lt;/p>
&lt;p>Storing a vector is not new in PostgreSQL. The PostgreSQL &lt;a href="https://www.postgresql.org/docs/current/arrays.html">array type&lt;/a> was around when PostgreSQL was first open-sourced in 1996(!), though there were many improvements made to it through the years. In fact, PostgreSQL &amp;ldquo;arrays&amp;rdquo; is a bit of a misnomer, as they can store multiple dimensions of data (e.g. a matrix). Natively in PostgreSQL arrays contain limited functionality around operations that are common amongst vectors, e.g. calculating the &amp;ldquo;distance&amp;rdquo; between two arrays. It&amp;rsquo;s possible to write stored procedures to handle this, but that puts extra work on the developer.&lt;/p>
&lt;p>Fortunately, the &lt;a href="https://www.postgresql.org/docs/current/cube.html">&lt;code>cube&lt;/code>&lt;/a> data type overcomes these limitations. &lt;code>cube&lt;/code> has also been around for 20+ years in the PostgreSQL code base, and is designed for performing operations on higher dimensional vectors* (more on that in a second). &lt;code>cube&lt;/code> contains most of the common distance functions used in vector similarity searches, including Euclidean distance, and can use GiST indexes to perform efficient K-NN queries! However, &lt;code>cube&lt;/code> is capped at storing vectors with 100 dimensions, and many modern AI/ML systems have dimensionality that far exceeds that.&lt;/p>
&lt;p>So, if arrays can handle vector dimensionality, but not operations, and &lt;code>cube&lt;/code>s can handle operations, but not dimensionality, what can we do?&lt;/p>
&lt;h2 id="pgvectorhttpsgithubcompgvectorpgvector-an-open-source-extension-for-storing-and-searching-vectors-in-postgresql">&lt;a href="https://github.com/pgvector/pgvector">&lt;code>pgvector&lt;/code>&lt;/a>: an open source extension for storing and searching vectors in PostgreSQL&lt;/h2>
&lt;p>One of the foundations of PostgreSQL is its extensibility: PostgreSQL has interfaces to create new data types and new indexing methods. This gives us &lt;a href="https://github.com/pgvector/pgvector">pgvector&lt;/a>, an open source &lt;a href="https://www.postgresql.org/docs/current/extend-extensions.html">PostgreSQL extension&lt;/a> that provides an indexable &lt;code>vector&lt;/code> data type. In a nutshell, pgvector lets you store vectors in PostgreSQL and perform K-NN queries with an assortment of distance metrics: Euclidean, cosine, and inner product. As of today, pgvector comes with one index, &lt;code>ivfflat&lt;/code>, which implements the &lt;a href="https://github.com/facebookresearch/faiss/wiki/Faiss-indexes">IVF FLAT&lt;/a> method of vector indexing.&lt;/p>
&lt;p>What happens when you query indexed vector data may be a bit different than how you&amp;rsquo;re used to querying data in PostgreSQL. Due to the computational expense of performing nearest-neighbor searches over high-dimensionality vectors, many vector indexing methods look for &amp;ldquo;approximate&amp;rdquo; answers that are &amp;ldquo;close enough&amp;rdquo; to the correct answer. This has lead to the field of &amp;ldquo;Approximate Nearest Neighbor&amp;rdquo; (ANN) searches. The two dimensions that people look at for ANN queries are the tradeoff between performance and &amp;ldquo;&lt;a href="https://en.wikipedia.org/wiki/Precision_and_recall">recall&lt;/a>&amp;rdquo;, where &amp;ldquo;recall&amp;rdquo; is the percentage of relevant results returned.&lt;/p>
&lt;p>Let&amp;rsquo;s look at the &lt;code>ivfflat&lt;/code> method as an example. When building an &lt;code>ivfflat&lt;/code> index, you decide how many &lt;code>lists&lt;/code> you want to have in it. Each &lt;code>list&lt;/code> represents a &amp;ldquo;center&amp;rdquo;; these centers are calculated using a &lt;a href="https://en.wikipedia.org/wiki/K-means_clustering">k-means&lt;/a> algorithm. Once you determine all of your centers, &lt;code>ivfflat&lt;/code> determines what center each vector is closest to and adds it to the index. When it&amp;rsquo;s time to query your vector data, you then decide how many centers to check, which is determined by the &lt;code>ivfflat.probes&lt;/code> parameter. This is where you see the ANN performance/recall tradeoff: the more centers you visit, the more precise your results, but at the expense of performance.&lt;/p>
&lt;p>Because of the popularity of storing the output of AI/ML in &amp;ldquo;vector databases&amp;rdquo; and of &lt;code>pgvector&lt;/code>, there are plenty of examples for how to use &lt;code>pgvector&lt;/code>. So instead, I&amp;rsquo;ll focus on where things are heading.&lt;/p>
&lt;h1 id="the-next-steps-for-better-support-for-vectors-in-postgresql">The next steps for better support for vectors in PostgreSQL&lt;/h1>
&lt;p>Similar to the PostgreSQL 9.2 days of JSON, we&amp;rsquo;re in the earlier stages of how we store vector data in PostgreSQL &amp;ndash; and while a lot of what we see in both PostgreSQL and pgvector is very good, it&amp;rsquo;s about to get a whole lot better.&lt;/p>
&lt;p>&lt;code>pgvector&lt;/code> can already handle many common use cases for AI/ML data &amp;ndash; I&amp;rsquo;ve already seen many users successfully deploy apps with it! &amp;ndash; so the next step is to help it scale. This is not too different from what happened with JSON and JSONB in PostgreSQL, but having &lt;code>pgvector&lt;/code> as an extension will help things to iterate more rapidly.&lt;/p>
&lt;p>At &lt;a href="https://www.pgcon.org/2023/">PGCon 2023&lt;/a>, which is a PostgreSQL conference where many internals developers gather, I presented a lightning talk called &lt;a href="https://www.slideshare.net/jkatz05/vectors-are-the-new-json-in-postgresql">Vectors are the new JSON&lt;/a> where I shared use-cases and some upcoming challenges with improving PostgreSQL and &lt;code>pgvector&lt;/code> performance for querying vector data. Some problems to tackle (many of which are in progress!) involve adding more parallelism to pgvector, adding support for indexing for vectors with more than 2,000 dimensions, and leverage hardware acceleration where possible to speed up calculations. The good news is that some of these things are not too hard to add, they just require open source contributions!&lt;/p>
&lt;p>There is a lot of excitement around using PostgreSQL as a vector database (emphasis on &lt;strong>database&lt;/strong> ;-), and I expect that, as history has shown with JSON, the PostgreSQL community will find a way to support this emergent workload in a way that&amp;rsquo;s scalable and safe. I do encourage you to provide feedback &amp;ndash; both on PostgreSQL itself and pgvector &amp;ndash; on how you&amp;rsquo;re working with vector data in PostgreSQL, or how you want to work with data in PostgreSQL, as that will help guide the community on providing optimal support for vector queries.&lt;/p></description></item><item><title>A tribute to PostgreSQL 10</title><link>https://jkatz.github.io/post/postgres/postgres-10-tribute/</link><pubDate>Thu, 10 Nov 2022 00:00:00 +0000</pubDate><guid>https://jkatz.github.io/post/postgres/postgres-10-tribute/</guid><description>&lt;p>The &lt;a href="https://www.postgresql.org/about/news/postgresql-151-146-139-1213-1118-and-1023-released-2543/">last release of PostgreSQL 10&lt;/a> took place on Nov 10, 2022. While there are many articles on the new and exciting features in PostgreSQL, I thought this would be a good time to reflect on the impact of PostgreSQL 10.&lt;/p>
&lt;p>PostgreSQL 10 had a lot of firsts. It was the first PostgreSQL release to have the two digit numbering scheme (PostgreSQL 10 vs. PostgreSQL 9.6). It was the first release with logical replication, declarative partitioning, and SCRAM.&lt;/p>
&lt;p>The PostgreSQL 10 release also had personal significance. The &lt;a href="https://www.postgresql.org/about/news/postgresql-10-released-1786/">release announcement&lt;/a> was the first major version release where I helped to assemble the different pieces. This involved reading through the release notes, asking developers what exactly they built, iterating through the content of the release with the community, and working with our international community to localize and translate the content (and if you are interested in helping with any of this process, reach out to me!).&lt;/p>
&lt;p>As we are now at the final release of PostgreSQL 10, I wanted to take a moment to memorialize this release and review the lasting impact it has had on the project and how people run their database workloads on PostgreSQL.&lt;/p>
&lt;h2 id="whats-in-a-number-moving-from-xyz--xy">What&amp;rsquo;s in a number? Moving from X.Y.Z =&amp;gt; X.Y&lt;/h2>
&lt;p>One of the hardest problems in computer science is naming things. There is a corollary that &lt;a href="https://www.postgresql.org/message-id/flat/CA%2BTgmoa2HVxpTUOjTvEMDrZfmdoFuJ3BMaBDE1Y5xAnA%3DXiRLw%40mail.gmail.com">versioning is a close second&lt;/a>. There are a variety of reasons why PostgreSQL moved from a &lt;code>X.Y.Z&lt;/code> versioning scheme to a &lt;code>X.Y&lt;/code>, but one that stood out to me was around the clarity of upgrading. It is easier to explain the upgrade jump between a &amp;ldquo;10&amp;rdquo; and &amp;ldquo;11&amp;rdquo; than a &amp;ldquo;9.5&amp;rdquo; and &amp;ldquo;9.6&amp;rdquo;. It also help remove the terms like &amp;ldquo;PostgreSQL 9&amp;rdquo; from the lexicon, especially given the huge feature difference between 9.0 and 9.6.&lt;/p>
&lt;p>It did take some time to propagate information for how this worked &amp;ndash; for years the release announcements included guidance on the new numbering scheme. Of everything in the PostgreSQL 10 release, this is arguably the most impactful change simply based on how it made people talk about PostgreSQL.&lt;/p>
&lt;h2 id="parallelize-all-the-things">Parallelize &amp;ldquo;all the things!&amp;rdquo;&lt;/h2>
&lt;p>PostgreSQL 9.6 was the first release to introduce parallel query, or the ability to have multiple workers simultaneously retrieve data. PostgreSQL 10 &lt;a href="https://www.postgresql.org/docs/10/release-10.html#id-1.11.6.28.5.3.2">greatly built on this functionality&lt;/a> and added many more parallel operations.&lt;/p>
&lt;p>What I found amazing about this functionality was its immediate impact upon upgrading. Where I was working at the time, I had our production OLTP workload running PostgreSQL 9.4. I began profiling our workload against a PostgreSQL 10 instance, and just with upgrading, I saw a 2.5x speedup over our &lt;strong>entire workload&lt;/strong>. When I drilled into it further, I observed that the parallel query work was a big driver of this.&lt;/p>
&lt;p>There have been a lot of enhancements since PostgreSQL 10 that have made similar &amp;ldquo;just upgrade to get big performance improvements&amp;rdquo;, whether it is around indexing, concurrency management, or query performance optimizations. But I distinctly remember how impressed I was that I could update to PostgreSQL 10 and observe a site-wide performance improvement with minimal tuning.&lt;/p>
&lt;h2 id="an-easier-and-better-way-to-partition">An easier (and better) way to partition&lt;/h2>
&lt;p>Longtime PostgreSQL users note that PostgreSQL had partitioning before PostgreSQL 10. You could create partitioned data using PostgreSQL &amp;ldquo;rules&amp;rdquo; system to help place it into different tables and query it. For a college internship, I actually used this system as part of segmenting and storing data for US TV channel schedules, though it did take a bit of work to set up and maintain the rules system.&lt;/p>
&lt;p>PostgreSQL 10 lowered the complexity of partition management in PostgreSQL by letting users create partitions with simple SQL commands. While subsequent releases expanded the partitioning functionality and improved its performance, PostgreSQL 10 laid the groundwork for this essential feature. You can see the impact of PostgreSQL&amp;rsquo;s partitioning support in the extension ecosystem too, as many extensions either provided more management functions or query mechanisms over data with lots of partitions.&lt;/p>
&lt;h2 id="publishers-subscribers-logical-replication-comes-to-postgresql">Publishers, subscribers: logical replication comes to PostgreSQL&lt;/h2>
&lt;p>When physical replication, or copying the binary data stored on disk between PostgreSQL servers, was introduced in PostgreSQL 9.0, one of the next asks was for logical replication. Logical replication has many uses, including moving data between two different writable PostgreSQL systems, or different major versions, or even into other databases! PostgreSQL 9.4 introduced the fundamental layer for logical replication in PostgreSQL: the ability to &amp;ldquo;decode&amp;rdquo; statements into a different format. This spawned various logical decoding output plugins, including &lt;a href="https://github.com/eulerto/wal2json">wal2json&lt;/a> that turned PostgreSQL writes into JSON that could be used in applications (e.g. &lt;a href="https://en.wikipedia.org/wiki/Change_data_capture">change data capture&lt;/a>).&lt;/p>
&lt;p>PostgreSQL 10 added direct support for &lt;a href="https://www.postgresql.org/docs/current/logical-replication.html">logical replication&lt;/a>, introducing the ability to create publications and subscribers between databases. Instead of relying on extensions or custom-built solutions, PostgreSQL users could run &lt;code>CREATE PUBLICATION&lt;/code> and &lt;code>CREATE SUBSCRIPTION&lt;/code> to set up logical replication.&lt;/p>
&lt;p>Fast forward to today (PostgreSQL 15) and you see a whole array of products using PostgreSQL logical replication as part of their change data capture functionality, major version upgrades, or part of their replication strategy.
While at Crunchy Data, I wrote up a blog post on how you can combine two features originally introduced in PostgreSQL 10 &amp;ndash; declarative partitioning and logical replication &amp;ndash; to create an &lt;a href="https://www.crunchydata.com/blog/active-active-postgres-federation-on-kubernetes">active-active federated PostgreSQL clusters&lt;/a>.&lt;/p>
&lt;p>As of this writing, there is still a bunch of ongoing work on logical replication in PostgreSQL, including making it possible to replicate more objects like sequences and DDL commands. But I remember the release of PostgreSQL 10 being a release that significantly helped users in how they could move data between systems.&lt;/p>
&lt;h2 id="reaching-a-quorum">Reaching a quorum&lt;/h2>
&lt;p>During the PostgreSQL 10 release, I was less familiar with how high availability systems work. While I knew adding &amp;ldquo;quorum commit&amp;rdquo; for synchronous replication was a big feature, I did not fully understand why.&lt;/p>
&lt;p>Here&amp;rsquo;s how to think of quorum commit. Let&amp;rsquo;s say you have 5 PostgreSQL instances: 1 primary and 4 standbys. You can set a rule that you consider a transaction to be committed if it is written to at least 3 instances. Prior to PostgreSQL 10, if you were using synchronous replication, a transaction would only be considered committed if it was written to &lt;strong>all&lt;/strong> instances, not a subset of them.&lt;/p>
&lt;p>Adding quorum commit advanced PostgreSQL&amp;rsquo;s ability to be a part of high availability systems. It also made it easier to use synchronous replicas with PostgreSQL, reducing performance and availability burdens. If you&amp;rsquo;re interested in how many high availability systems work, read up on the &lt;a href="https://raft.github.io/">Raft algorithm&lt;/a>. The paper itself is not too difficult a read (though I did read through sections a few times to understand them), but it does show the significance of a quorum commit.&lt;/p>
&lt;h2 id="making-password-more-secure">Making password more secure&lt;/h2>
&lt;p>I&amp;rsquo;m an unabashed proponent of using the &lt;a href="https://www.rfc-editor.org/rfc/rfc5802">SCRAM password authentication method&lt;/a>. Seriously, &lt;a href="https://www.slideshare.net/jkatz05/get-your-insecure-postgresql-passwords-to-scram">I will talk to you for an hour (or longer if you let me) on why you should use SCRAM&lt;/a>. But why?&lt;/p>
&lt;p>Before PostgreSQL 10, the primary way to use PostgreSQL authentication was with its own &lt;code>md5&lt;/code> authentication method. The &lt;code>md5&lt;/code> method has &lt;a href="https://www.postgresql.org/docs/current/auth-password.html">some known flaws&lt;/a>, including that someone who has the stored &lt;code>md5&lt;/code> and its corresponding username can log in as that username.&lt;/p>
&lt;p>SCRAM changes that. The SCRAM method, in a nutshell, lets two parties verify that the other knows a password without exchanging the password. Even if an attacker is able to capture the &amp;ldquo;SCRAM secret&amp;rdquo; stored on a server, their options for learning the credential are either through a 1/ MITM attack (which can be mitigated through good TLS practices, i.e. &lt;code>sslmode=verify-full&lt;/code>) or 2/ brute-forcing the password.&lt;/p>
&lt;p>Using SCRAM required changes to &lt;a href="https://wiki.postgresql.org/wiki/List_of_drivers">PostgreSQL drivers&lt;/a>. The community responded: you can see from that list that all the libpq and non-libpq based drivers added support for SCRAM. This allowed PostgreSQL to make SCRAM the default authentication method in PostgreSQL 14, and hopefully in the future we can remove &lt;code>md5&lt;/code> altogether.&lt;/p>
&lt;h2 id="lost-at-the-time-found-later-on">Lost at the time, found later on&lt;/h2>
&lt;p>The above features were major highlights in the &lt;a href="https://www.postgresql.org/about/news/postgresql-10-released-1786/">PostgreSQL 10 release announcement&lt;/a>. They withstood the &amp;ldquo;test of time&amp;rdquo; and continue to have impact on users of newer PostgreSQL releases.&lt;/p>
&lt;p>But there were other PostgreSQL 10 features that also had significant impact though lacked fanfare. I&amp;rsquo;m sure I am going to miss some, but here are the ones that I noticed while re-reading the PostgreSQL 10 release notes.&lt;/p>
&lt;p>PostgreSQL 10 introduced the ability to &amp;ldquo;push&amp;rdquo; joins and aggregates to PostgreSQL servers being accessed through the &lt;a href="https://www.postgresql.org/docs/current/postgres-fdw.html">&lt;code>postgres_fdw&lt;/code>&lt;/a>. Instead of having to pull all the data using joins and aggregates from remote PostgreSQL servers into a single-PostgreSQL server for processing, which is a potentially exhaustive operation, that work could be handled on remote servers and reduce the amount of data that needed to be transferred. This has had significant ramifications for federated or sharded workloads, as it decreased the burden on the primary instance.&lt;/p>
&lt;p>PostgreSQL 10 also introduced &amp;ldquo;identity columns&amp;rdquo;, a SQL standard way for specifying &lt;code>serial&lt;/code> or an autoincrement. This means that:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">xyz&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">serial&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>can be written as:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">xyz&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">GENERATED&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DEFAULT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">IDENTITY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>and be SQL compliant. My SQL code and examples now use the identity column syntax!&lt;/p>
&lt;p>PostgreSQL 10 also added the &lt;a href="https://www.postgresql.org/docs/current/amcheck.html">&lt;code>amcheck&lt;/code>&lt;/a> extension, which has become an essential DBA tool for finding data corruption. PostgreSQL 14 later introduced &lt;a href="https://www.postgresql.org/docs/15/app-pgamcheck.html">&lt;code>pg_amcheck&lt;/code>&lt;/a> to provide a CLI for detecting data corruption.&lt;/p>
&lt;p>Finally, PostgreSQL 10 added the ability to change TLS configuration using a &amp;ldquo;reload&amp;rdquo; instead of a &amp;ldquo;restart&amp;rdquo;. I became a huge fan of this feature when helping to build a system that had automatic rotation of TLS certificates in a PostgreSQL server without forcing any user downtime.&lt;/p>
&lt;h2 id="conclusion-postgresql-10-lives-on">Conclusion: PostgreSQL 10 lives on&lt;/h2>
&lt;p>PostgreSQL has come a long way since the PostgreSQL 10 release five years ago. Given how transformative this release was, and how impactful it has remained over these past five years, I wanted to ensure we could give it an appropriate tribute for its final update.&lt;/p>
&lt;p>It&amp;rsquo;s also important to reflect how far PostgreSQL has come, even in the past five years, from both a functionality and adoption standpoint. I&amp;rsquo;m still amazed at all the conversations I have with people over what kinds of workloads they&amp;rsquo;re running with PostgreSQL, what features they are using and enjoying, and all the different ways they are deploying PostgreSQL!&lt;/p>
&lt;p>While there is always more work to do (e.g. see my comments on ongoing logical replication work), it&amp;rsquo;s also good to step back at how far PostgreSQL has come, and celebrate the releases that helped move the project significantly forward.&lt;/p>
&lt;p>&amp;hellip;and while PostgreSQL 10 was an impactful release, if you are still using it in production, you should seriously consider upgrading 😉&lt;/p></description></item><item><title>BEGIN ATOMIC: a better way to create functions in PostgreSQL 14</title><link>https://jkatz.github.io/post/postgres/postgres-begin-atomic/</link><pubDate>Tue, 26 Jul 2022 00:00:00 +0000</pubDate><guid>https://jkatz.github.io/post/postgres/postgres-begin-atomic/</guid><description>&lt;p>Around this time of year, I am reading through the upcoming PostgreSQL release notes (hello &lt;a href="https://www.postgresql.org/docs/15/release-15.html">PostgreSQL 15&lt;/a>), reading &lt;a href="https://www.postgresql.org/list/">mailing lists&lt;/a>, and talking to &lt;a href="https://www.postgresql.org">PostgreSQL&lt;/a> users to understand what are the impactful features. Many of these features will be highlighted in the &lt;a href="https://www.postgresql.org/about/featurematrix/">feature matrix&lt;/a> and release announcement (hello &lt;a href="https://www.postgresql.org/about/press/presskit14/">PostgreSQL 14&lt;/a>!).&lt;/p>
&lt;p>However, sometimes I miss an impactful feature. It could be that we need to see how the feature is actually used post-release, or it could be that it was missed. I believe one such change is the introduction of the SQL-standard &lt;code>BEGIN ATOMIC&lt;/code> syntax in PostgreSQL 14 that is used to create function and stored procedure bodies.&lt;/p>
&lt;p>Let&amp;rsquo;s see how functions we could create functions before PostgreSQL 14, the drawbacks to this method, and how going forward, &lt;code>BEGIN ATOMIC&lt;/code> makes it easier and safer to manage functions!&lt;/p>
&lt;h2 id="before-postgresql-14-creating-functions-as-strings">Before PostgreSQL 14: Creating Functions as Strings&lt;/h2>
&lt;p>PostgreSQL has supported the ability to create stored functions (or &amp;ldquo;user-defined functions&amp;rdquo;) since POSTGRES 4.2 in 1994 (thanks [Bruce Momjian[(https://momjian.us/)] for the answer on this). When declaring the function body, you would write the code as a string (which is why you see the &lt;code>$$&lt;/code> marks in functions). For example, here is a simple function to add two numbers:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FUNCTION&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">RETURNS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LANGUAGE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SQL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">IMMUTABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PARALLEL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SAFE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">$$&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">$$&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If I want to have functions that calls another user-defined function, I can do so similarly to the above. For example, here is a function that uses the &lt;code>add&lt;/code> function to add up a whole bunch of numbers:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FUNCTION&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">test1_add_stuff&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">RETURNS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LANGUAGE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SQL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">IMMUTABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PARALLEL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SAFE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">$$&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">$$&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>After I create the two functions, if I try to run &lt;code>test1_add_stuff&lt;/code>, it works:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT test1_add_stuff(1,2,3,4);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> test1_add_stuff
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-----------------
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 10
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>What happens if I drop the &lt;code>add&lt;/code> function?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">DROP&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FUNCTION&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>It drops successfully:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">DROP FUNCTION add(int, int);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">DROP FUNCTION
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And if I try calling &lt;code>test1_add_stuff&lt;/code> again?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT test1_add_stuff(1,2,3,4);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ERROR: function add(integer, integer) does not exist
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LINE 2: SELECT add(add($1, $2), add($3, $4));
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ^
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HINT: No function matches the given name and argument types. You might need to add explicit type casts.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">QUERY:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT add(add($1, $2), add($3, $4));
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CONTEXT: SQL function &amp;#34;test1_add_stuff&amp;#34; during startup
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Well, this stinks. Using the pre-v14 style of creating custom functions in PostgreSQL lacks dependency tracking. So dropping one function could end up breaking other functions.&lt;/p>
&lt;p>PostgreSQL does support &lt;a href="https://www.postgresql.org/docs/current/ddl-depend.html">dependency tracking&lt;/a>. Prior to PostgreSQL 14, PostgreSQL could track dependencies in functions that involve attributes such as arguments or returns types, but it could not track dependencies within a function body.&lt;/p>
&lt;p>This is where &lt;code>BEGIN ATOMIC&lt;/code> function bodies changes things.&lt;/p>
&lt;h2 id="begin-atomic-a-better-way-to-create-and-manage-postgresql-user-defined-functions">BEGIN ATOMIC: a better way to create and manage PostgreSQL user-defined functions&lt;/h2>
&lt;p>I started looking at the &lt;code>BEGIN ATOMIC&lt;/code> method of creating functions &lt;a href="https://www.postgresql.org/message-id/CAKqncciYKMZSNM0LZuCYoKsGgDBxE%3D%3DLEAAH0svqmajYhO1oxw%40mail.gmail.com">thanks to a note from Morris de Oryx&lt;/a> on the usefulness of this feature (and the fact it was &lt;a href="https://www.postgresql.org/about/featurematrix/detail/393/">previously missing from the feature matrix&lt;/a>). Morris succinctly pointed out two of the most impactful attributes of creating a PostgreSQL function with &lt;code>BEGIN ATOMIC&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>Because PostgreSQL parses the functions during creation, it can catch additional errors.&lt;/li>
&lt;li>PostgreSQL has improved dependency tracking of functions.&lt;/li>
&lt;/ul>
&lt;p>Let&amp;rsquo;s use the above example again to see how &lt;code>BEGIN ATOMIC&lt;/code> changes things.&lt;/p>
&lt;h3 id="dependency-tracking">Dependency Tracking&lt;/h3>
&lt;p>Let&amp;rsquo;s create the &lt;code>add&lt;/code> function using the &lt;code>BEGIN ATOMIC&lt;/code> syntax:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FUNCTION&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">RETURNS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LANGUAGE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SQL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">IMMUTABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PARALLEL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SAFE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">BEGIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ATOMIC&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">END&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice the difference: the function body is no longer represented as a string, but actual code statements. Let&amp;rsquo;s now create a new function called &lt;code>test2_add_stuff&lt;/code> that will use the &lt;code>add&lt;/code> function:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FUNCTION&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">test2_add_stuff&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">RETURNS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LANGUAGE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SQL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">IMMUTABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PARALLEL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SAFE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">BEGIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ATOMIC&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">END&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As expected, &lt;code>test2_add_stuff&lt;/code> should work correctly:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT test2_add_stuff(1,2,3,4);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> test2_add_stuff
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-----------------
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 10
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>What happens if we try to drop the &lt;code>add&lt;/code> function now?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">DROP FUNCTION add(int,int);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ERROR: cannot drop function add(integer,integer) because other objects depend on it
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">DETAIL: function test2_add_stuff(integer,integer,integer,integer) depends on function add(integer,integer)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HINT: Use DROP ... CASCADE to drop the dependent objects too.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is awesome: using &lt;code>BEGIN ATOMIC&lt;/code> when for functions guards against dropping a function that is called by one or more other functions!&lt;/p>
&lt;h3 id="creation-time-parsing-checks">Creation Time Parsing Checks&lt;/h3>
&lt;p>Let&amp;rsquo;s look at one more example at how &lt;code>BEGIN ATOMIC&lt;/code> helps us avoid errors.&lt;/p>
&lt;p>Prior to PostgreSQL 14, there are some checks that do occur at function creation time. For example, let&amp;rsquo;s create a function that calls a function that calls a function.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FUNCTION&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">RETURNS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LANGUAGE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SQL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">IMMUTABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PARALLEL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SAFE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">$$&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">$$&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FUNCTION&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">RETURNS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LANGUAGE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SQL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">IMMUTABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PARALLEL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SAFE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">$$&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">$$&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FUNCTION&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">RETURNS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LANGUAGE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SQL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">IMMUTABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PARALLEL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SAFE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">$$&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">$$&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Calling &lt;code>c&lt;/code> should work as expected:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT c(1);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> c
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">---
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 6
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s drop both &lt;code>a&lt;/code> and &lt;code>c&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">DROP&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FUNCTION&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">DROP&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FUNCTION&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>What happens when we recreate &lt;code>c&lt;/code>?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">CREATE FUNCTION c(int)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RETURNS int
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LANGUAGE SQL
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">IMMUTABLE PARALLEL SAFE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">AS $$
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT b($1);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$$;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CREATE FUNCTION
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The function creation works, even though &lt;code>a&lt;/code> is still missing. While functions created without &lt;code>BEGIN ATOMIC&lt;/code> can check for dependencies within the body of the function itself, they do not check throughout the entire parse tree. We can see our call to &lt;code>c&lt;/code> fail due to &lt;code>a&lt;/code> still missing:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT c(3);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ERROR: function a(integer) does not exist
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LINE 2: SELECT a($1) * 2;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ^
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HINT: No function matches the given name and argument types. You might need to add explicit type casts.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">QUERY:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT a($1) * 2;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CONTEXT: SQL function &amp;#34;b&amp;#34; during inlining
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SQL function &amp;#34;c&amp;#34; during startup
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Using &lt;code>BEGIN ATOMIC&lt;/code> for creating all of these functions will prevent us from getting into this situation, as PostgreSQL will scan the parse tree to ensure all of these functions exist. Let&amp;rsquo;s now recreate the functions to use &lt;code>BEGIN ATOMIC&lt;/code> for their function bodies:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">OR&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">REPLACE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FUNCTION&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">RETURNS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LANGUAGE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SQL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">IMMUTABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PARALLEL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SAFE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">BEGIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ATOMIC&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">END&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">OR&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">REPLACE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FUNCTION&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">RETURNS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LANGUAGE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SQL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">IMMUTABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PARALLEL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SAFE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">BEGIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ATOMIC&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">END&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">OR&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">REPLACE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FUNCTION&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">RETURNS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LANGUAGE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SQL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">IMMUTABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PARALLEL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SAFE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">BEGIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ATOMIC&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">END&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, try dropping &lt;code>a&lt;/code> - PostgreSQL will prevent this from happening.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">DROP FUNCTION a(int);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ERROR: cannot drop function a(integer) because other objects depend on it
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">DETAIL: function b(integer) depends on function a(integer)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">function c(integer) depends on function b(integer)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HINT: Use DROP ... CASCADE to drop the dependent objects too.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Great. But what happens if I do a &lt;code>DROP FUNCTION ... CASCADE&lt;/code> on function &lt;code>a&lt;/code>?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">DROP FUNCTION a(int) CASCADE;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">NOTICE: drop cascades to 2 other objects
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">DETAIL: drop cascades to function b(integer)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">drop cascades to function c(integer)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">DROP FUNCTION
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>PostgreSQL drops &lt;strong>all&lt;/strong> functions that depend on &lt;code>a&lt;/code>, including both &lt;code>b&lt;/code> and &lt;code>c&lt;/code>. While this is handy for cleaning up a test example, be careful when cascading drops on our production systems so you do not accidentally remove an important object!&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>The &lt;code>BEGIN ATOMIC&lt;/code> syntax for creating PostgreSQL functions should make managing user-defined functions less error prone, particularly the &amp;ldquo;accidental dropped function&amp;rdquo; case. Going forward I will definitely use this feature to manage my PostgreSQL stored functions.&lt;/p>
&lt;p>PostgreSQL releases are packed with new features. In fact, PostgreSQL 14 has over 190 features listed in the release notes! This makes it possible to miss a feature that may make it much easier for you to build applications with PostgreSQL. I encourage you to read the &lt;a href="https://www.postgresql.org/docs/release/">release notes&lt;/a> to see if there is a feature in them that will help your PostgreSQL experience!&lt;/p></description></item><item><title>Notes on updating to PostgreSQL 14.3, 13.7, 12.11, 11.16, and 10.21</title><link>https://jkatz.github.io/post/postgres/may-2022-release-should-i-update/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>https://jkatz.github.io/post/postgres/may-2022-release-should-i-update/</guid><description>&lt;p>On May 12, 2022, the PostgreSQL Global Development Group
&lt;a href="https://www.postgresql.org/about/news/postgresql-143-137-1211-1116-and-1021-released-2449/">released its regular quarterly update&lt;/a> for all of its supported versions (10-14) containing
bug fixes and a security fix for &lt;a href="https://www.postgresql.org/support/security/CVE-2022-1552/">CVE-2022-1552&lt;/a>. Per its &lt;a href="https://www.postgresql.org/support/versioning/">versioning policy&lt;/a>,
the PostgreSQL community advises that users run the
&amp;ldquo;&lt;a href="https://www.postgresql.org/support/versioning/">latest available minor release available for a major version&lt;/a>.&amp;rdquo;
This is generally the correct approach: update releases make each major release
more stable, and the community makes a concerted effort to avoid introducing
breaking changes. You should &lt;em>always&lt;/em> test each update release before releasing
it into your production environment.&lt;/p>
&lt;p>However, there are a few issues that you should be aware when deciding to
upgrade. One issue affects all versions of PostgreSQL 14 through versions 14.3,
and one issue is specific to the May 12, 2022 release You do need to weigh the
decision to upgrade against incorporating the fix for CVE-2022-1552 and the
&lt;a href="https://www.postgresql.org/about/news/postgresql-143-137-1211-1116-and-1021-released-2449/">other bug fixes available in this release&lt;/a>.&lt;/p>
&lt;p>The below explains what each issue is, what versions of PostgreSQL it effects,
the tradeoffs around upgrading and any remediations.&lt;/p>
&lt;h2 id="create-index-concurrently--reindex-concurrently-on-postgresql-14">&lt;code>CREATE INDEX CONCURRENTLY&lt;/code> / &lt;code>REINDEX CONCURRENTLY&lt;/code> on PostgreSQL 14&lt;/h2>
&lt;p>Vacuuming is an
&lt;a href="https://www.postgresql.org/docs/current/routine-vacuuming.html">essential part of PostgreSQL maintenance&lt;/a>
that performs actions such as reclaiming disk space from updated and deleted
rows. The &lt;a href="https://www.postgresql.org/about/news/postgresql-14-released-2318/">GA release of PostgreSQL 14&lt;/a>
(14.0) introduced an
&lt;a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=d9d076222f5b">optimization for &lt;code>VACUUM&lt;/code> when &lt;code>CREATE INDEX CONCURRENTLY&lt;/code> and &lt;code>REINDEX CONCURRENTLY&lt;/code>&lt;/a> were
running at the same time.&lt;/p>
&lt;p>There were a few
&lt;a href="https://www.postgresql.org/message-id/17485-396609c6925b982d%40postgresql.org">bug reports of index corruption in PostgreSQL 14&lt;/a> and shortly after the PostgreSQL 14.3
release, several members of the PostgreSQL community were able to consistently
reproduce the issue. The optimization described in the above paragraph could
lead to cases of silent index corruption when indexes are built with
&lt;a href="https://www.postgresql.org/docs/current/sql-createindex.html">&lt;code>CREATE INDEX CONCURRENTLY&lt;/code>&lt;/a>
or &lt;a href="https://www.postgresql.org/docs/current/sql-reindex.html">&lt;code>REINDEX CONCURRENTLY&lt;/code>&lt;/a>.
The issue was present since PostgreSQL 14.0: it does not affect any of the other
supported versions of PostgreSQL (i.e.. PostgreSQL 10 - 13).&lt;/p>
&lt;p>After some discussion, the PostgreSQL community decided to
&lt;a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=e28bb885196916b0a3d898ae4f2be0e38108d81b">revert the &lt;code>VACUUM&lt;/code> optimization&lt;/a> for
the time being until a solution that does not contain the risk of silent index
corruption can be implemented. The community has discussed how to best detect
this corruption issue using
&lt;a href="https://www.postgresql.org/docs/current/app-pgamcheck.html">&lt;code>pg_amcheck&lt;/code>&lt;/a>,
specifically with the &lt;code>--heapallindexed&lt;/code> flag. This will take an
&lt;a href="https://www.postgresql.org/docs/current/explicit-locking.html">&lt;code>ACCESS SHARE&lt;/code>&lt;/a>
lock on each table, but it will not block &lt;code>VACUUM&lt;/code> and can be run on a standby.
Note that &lt;code>pg_amcheck&lt;/code> can only detect the corruption issue on B-tree indexes,
and the community is unsure if it can detect all cases of corruption.&lt;/p>
&lt;p>If you have run &lt;code>CREATE INDEX CONCURRENTLY&lt;/code> or &lt;code>REINDEX CONCURRENTLY&lt;/code> using
PostgreSQL 14 and need an immediate fix, you can fix your indexes by running
either running &lt;code>REINDEX&lt;/code> or dropping and recreating the index &lt;strong>without&lt;/strong> the
&lt;code>CONCURRENTLY&lt;/code> option. Once PostgreSQL 14.4 is available, you can use
&lt;code>CONCURRENTLY&lt;/code>. The
&lt;a href="https://www.postgresql.org/docs/current/app-reindexdb.html">&lt;code>reindexdb&lt;/code>&lt;/a>
command-line utility can help with the process as the &lt;code>--jobs&lt;/code> flag lets you
execute multiple &lt;code>REINDEX&lt;/code> operations at the same time across the entire
database.&lt;/p>
&lt;h2 id="a-brief-explanation-of-cve-2022-1552">A brief explanation of CVE-2022-1552&lt;/h2>
&lt;p>To understand the other issue, its first necessary to understand the impact of
CVE-2022-1552. As described,
&lt;a href="https://www.postgresql.org/support/security/CVE-2022-1552/">CVE-2022-1552&lt;/a>
closes a vulnerability where an unprivileged user can craft malicious SQL and
use certain commands (Autovacuum, &lt;code>REINDEX&lt;/code>, &lt;code>CREATE INDEX&lt;/code>,
&lt;code>REFRESH MATERIALIZED VIEW&lt;/code>, &lt;code>CLUSTER&lt;/code>, and &lt;code>pg_amcheck&lt;/code>) to escalate to become
a PostgreSQL superuser. A malicious user still needs to have an account with the
PostgreSQL system to perform this exploit.&lt;/p>
&lt;p>Systems that have unprivileged PostgreSQL users that have risk of SQL injection
(e.g. web applications) or multi-tenant systems may be particularly affected by
this CVE. While upgrading to 14.3 et al. fixes the issue, the community provides
guidance that if you cannot take this upgrade, you can still remediate the issue
by disabling autovacuum (with a warning on performance tradeoffs), not running
the above commands, and to not perform restores using the output from
&lt;code>pg_dump&lt;/code>.&lt;/p>
&lt;p>This issue affects all supported versions of PostgreSQL (10-14) but, as the CVE
notes, the issue is quite old and is not patched in unsupported versions (e.g.
9.6 and older).&lt;/p>
&lt;h2 id="creating-an-expression-index-using-an-operator-class-from-a-different-schema">Creating an expression index using an operator class from a different schema&lt;/h2>
&lt;p>Shortly after the May 12, 2022 update release, there was a report on the
PostgreSQL bugs mailing list where a user could not create an
&lt;a href="https://www.postgresql.org/docs/current/indexes-expressional.html">expression index&lt;/a>
as an unprivileged user when
&lt;a href="https://www.postgresql.org/message-id/flat/20220531152855.GA2236210%40nathanxps13#cf62ad5183084f9da0f458c446bb995d">using an operator class from a different schema that was created by a different user&lt;/a>.
Specifically, the case used the the
&lt;a href="https://www.postgresql.org/docs/current/pgtrgm.html#id-1.11.7.42.8">&lt;code>gist_trgm_ops&lt;/code>&lt;/a>
operator class from the &lt;code>pg_trgm&lt;/code> index to allow text similarity operators to be
indexable. While the issue was first reported based on the output of
&lt;a href="https://www.postgresql.org/docs/current/app-pgdump.html">&lt;code>pg_dump&lt;/code>&lt;/a>, this can
be reproduced in a straightforward way using a
&lt;a href="https://www.postgresql.org/message-id/20220526055047.GA3153526%40rfd.leadboat.com">few commands&lt;/a>.
There may be a few other cases where this issue may occur with other expression
indexes, but the above situation has been consistently reproduced.&lt;/p>
&lt;p>The fix for &lt;a href="https://www.postgresql.org/support/security/CVE-2022-1552/">CVE-2022-1552&lt;/a>
introduced this issue and only affects PostgreSQL 14.3, 13.7, 12.11, 11.16, and
10.21. As of the writing of this blog post, there is no fix available. For a
remediation, you can add the operator classes to the same schema where you are
creating the index. Ensure that any changes comply with the security posture
you are enforcing for your database.&lt;/p>
&lt;h2 id="should-i-upgrade-to-143-137-1211-1116-1021">Should I upgrade to 14.3, 13.7, 12.11, 11.16, 10.21?&lt;/h2>
&lt;p>If your database has a single-user and is the PostgreSQL superuser, you should
be able to upgrade without issues. Note that if you are on PostgreSQL 14, you
are still affected by the &lt;code>CREATE INDEX CONCURRENTLY&lt;/code> / &lt;code>REINDEX CONCURRENTLY&lt;/code>
issue and you should not use those commands until the fix is in place.&lt;/p>
&lt;p>For all other cases, you will need to weigh the tradeoffs of the above issues.
If you are on PostgreSQL 14, you will be affected by the
&lt;code>CREATE INDEX CONCURRENTLY&lt;/code> / &lt;code>REINDEX CONCURRENTLY&lt;/code> issue regardless if you
take this update. You should be aware of this issue and not run those commands.
If you have, you may need to reindex. The index corruption issue should not
prevent you from updating from PostgreSQL 14.3.&lt;/p>
&lt;p>If you are running a system that contains an unprivileged PostgreSQL user, you
will need to weigh the tradeoff of incorporating the fix for CVE-2022-1552
versus potential breakage with your application. The bug most likely shows
itself when performing &amp;ldquo;schema migrations&amp;rdquo; or restoring from a &lt;code>pg_dump&lt;/code>, but is
limited to if you are using any operator classes (e.g. for indexing) and how you
have structured your schemas. There may be some other unreported cases
that are affected by this issue, so be sure you test restoring your schema from
a &lt;code>pg_dump&lt;/code> (e.g. &lt;code>pg_dump --schema-only&lt;/code>).&lt;/p>
&lt;p>As the CVE mentions, you can still remediate the vulnerability without
upgrading, but there are performance and potentially stability risks with these
steps. Vacuuming is
&lt;a href="https://www.postgresql.org/docs/current/routine-vacuuming.html">an essential part of PostgreSQL maintenance&lt;/a>
and if you do not use it, your system can end up slowing down. In more extreme
cases, a system can hit
&lt;a href="https://www.postgresql.org/docs/current/routine-vacuuming.html#VACUUM-FOR-WRAPAROUND">transaction ID wraparound&lt;/a>,
which will put a PostgreSQL database into an unusable state.&lt;/p>
&lt;p>If you do not believe your application is affected by the issue with creating
indexes, you should consider upgrading. The fix for CVE-2022-1552 is much easier
to apply than the remediation steps. The remediation carries a risk of
performance degradation and instability for your system, so if you believe it is
safe to take the upgrade, you should do so.&lt;/p>
&lt;p>The PostgreSQL community guidance to
&lt;a href="https://www.postgresql.org/support/versioning/">run the latest release of a major version&lt;/a>
is a good best practice to follow. You should read through the
&lt;a href="https://www.postgresql.org/about/news/postgresql-143-137-1211-1116-and-1021-released-2449/">release announcement&lt;/a> and &lt;a href="https://www.postgresql.org/docs/release/">release notes&lt;/a>
to understand what fixes are available, and test your applications against the
update releases before deploying them to production.&lt;/p></description></item><item><title>"Read-Only" Mode for PostgreSQL</title><link>https://jkatz.github.io/post/postgres/postgres-read-only/</link><pubDate>Sun, 23 Jan 2022 00:00:00 +0000</pubDate><guid>https://jkatz.github.io/post/postgres/postgres-read-only/</guid><description>&lt;p>Typically when discussing having &amp;ldquo;read-only&amp;rdquo; connections to a &lt;a href="https://www.postgresql.org">PostgreSQL&lt;/a> database, it is in the context of connecting to a &lt;a href="https://www.postgresql.org/docs/current/high-availability.html">replica&lt;/a>.&lt;/p>
&lt;p>There are a variety of methods available to route connections with known read-only queries (i.e. queries with &lt;code>SELECT&lt;/code> statements&amp;hellip;that are not calling &lt;a href="https://www.postgresql.org/docs/current/xfunc-volatility.html">&lt;code>VOLATILE&lt;/code> functions&lt;/a> that modify data). This includes connection proxy software like &lt;a href="https://www.pgpool.net/">Pgpool-II&lt;/a> or framework mechanisms such as &lt;a href="https://docs.djangoproject.com/en/4.0/topics/db/multi-db/#automatic-database-routing">Django&amp;rsquo;s database router&lt;/a>.&lt;/p>
&lt;p>However, there are situations where you might need to force read-only connections to your primary (read-write) Postgres instance. Some examples include putting your application into a degraded state to perform a database move or upgrade, or allowing an administrator to inspect a system that may be accumulating &lt;a href="https://www.postgresql.org/docs/current/wal-intro.html">write-ahead logs&lt;/a> that track all changes to the system.&lt;/p>
&lt;p>PostgreSQL has a configuration parameter call &lt;a href="https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-DEFAULT-TRANSACTION-READ-ONLY">&lt;code>default_transaction_read_only&lt;/code>&lt;/a>. Setting &lt;code>default_transaction_read_only&lt;/code> globally to &lt;code>on&lt;/code> forces all connections to disallow writes to the database. &lt;code>default_transaction_read_only&lt;/code> is a reloadable parameter, so you do not need to restart your Postgres instance to use it.&lt;/p>
&lt;p>Here is a quick example of how &lt;code>default_transaction_read_only&lt;/code> works. First, ensure your system does not have &lt;code>default_transaction_read_only&lt;/code> set:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">postgres&lt;/span>&lt;span class="o">=#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">default_transaction_read_only&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">default_transaction_read_only&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">-------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">off&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">row&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">postgres&lt;/span>&lt;span class="o">=#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">IF&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">EXISTS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">abc&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">abc&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RETURNING&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">----
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">row&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This works as expected: we&amp;rsquo;re able to create a table and insert data. Now let&amp;rsquo;s put the system into &lt;code>default_transaction_read_only&lt;/code> mode (note that I am running this on &lt;a href="https://www.postgresql.org/about/news/postgresql-14-released-2318/">PostgreSQL 14&lt;/a>)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SYSTEM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">default_transaction_read_only&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">on&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">pg_reload_conf&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">default_transaction_read_only&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ensure that &lt;code>default_transaction_read_only&lt;/code> is enabled:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">postgres&lt;/span>&lt;span class="o">=#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">default_transaction_read_only&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">default_transaction_read_only&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">-------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">on&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">row&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now verify that writes are disallowed:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">postgres&lt;/span>&lt;span class="o">=#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">abc&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RETURNING&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">ERROR&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">cannot&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">execute&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">in&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">read&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="k">only&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">transaction&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Excellent!&lt;/p>
&lt;p>Note that &lt;code>default_transaction_read_only&lt;/code> is not a panacea: there are some &lt;a href="https://en.wikipedia.org/wiki/Caveat_emptor">caveats&lt;/a> that you should be aware of.&lt;/p>
&lt;p>First, &lt;code>default_transaction_read_only&lt;/code> can be overriden in a session, even if the value is set database-wide. For example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">postgres&lt;/span>&lt;span class="o">=#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">default_transaction_read_only&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">default_transaction_read_only&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">-------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">on&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">row&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">postgres&lt;/span>&lt;span class="o">=#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">default_transaction_read_only&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">off&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">postgres&lt;/span>&lt;span class="o">=#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">abc&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RETURNING&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">----
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">row&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Second, when utilizing &lt;code>default_transaction_read_only&lt;/code> with an application, you must also ensure your app can be configured to send only read queries to the database, ensuring a smooth user experience.&lt;/p>
&lt;p>That said, if you have a situation where you need to put a PostgreSQL primary instance into a &amp;ldquo;read-only&amp;rdquo; mode temporarily, you can use &lt;code>default_transaction_read_only&lt;/code> to prevent write transactions.&lt;/p></description></item></channel></rss>