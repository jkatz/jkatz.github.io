<!doctype html><html dir=ltr lang=en data-theme class="html theme--light"><head><meta charset=utf-8><title>Distributed queries for pgvector |
Jonathan Katz
</title><meta name=generator content="Hugo 0.139.2"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Jonathan Katz"><meta name=description content="How to run distributed pgvector queries using PostgreSQL partitioning and postgres_fdw on your vector data."><link rel=stylesheet href=/scss/main.min.8d4fad7e6916ad2e291e8d97ada157c70350d6d7150fea137e7243340967befb.css integrity="sha256-jU+tfmkWrS4pHo2XraFXxwNQ1tcVD+oTfnJDNAlnvvs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.73ccfdf28df555e11009c13c20ced067af3cb021504cba43644c705930428b00.css integrity="sha256-c8z98o31VeEQCcE8IM7QZ688sCFQTLpDZExwWTBCiwA=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/custom.min.3aab74359778ed24c5dcf7b0d36e04e4b55bbcb26e7d90240f41f946a075c1a5.css integrity="sha256-Oqt0NZd47STF3Pew024E5LVbvLJufZAkD0H5RqB1waU=" crossorigin=anonymous media=screen><link rel=stylesheet href=/fontawesome/css/fontawesome.min.137b1cf3cea9a8adb7884343a9a5ddddf4280f59153f74dc782fb7f7bf0d0519.css integrity="sha256-E3sc886pqK23iENDqaXd3fQoD1kVP3TceC+3978NBRk=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.e65dc5b48fb5f39b142360c57c3a215744c94e56c755c929cc3e88fe12aab4d3.css integrity="sha256-5l3FtI+185sUI2DFfDohV0TJTlbHVckpzD6I/hKqtNM=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.6f4f16d58da1c82c0c3a3436e021a3d39b4742f741192c546e73e947eacfd92f.css integrity="sha256-b08W1Y2hyCwMOjQ24CGj05tHQvdBGSxUbnPpR+rP2S8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.e10425ad768bc98ff1fb272a0ac8420f9d1ba22f0612c08ff1010c95080ffe7e.css integrity="sha256-4QQlrXaLyY/x+ycqCshCD50boi8GEsCP8QEMlQgP/n4=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicons/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicons/favicon-16x16.png><link rel=canonical href=https://jkatz.github.io/post/postgres/distributed-pgvector/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script><script type=text/javascript src=/js/anatole-theme-switcher.min.d6d329d93844b162e8bed1e915619625ca91687952177552b9b3e211014a2957.js integrity="sha256-1tMp2ThEsWLovtHpFWGWJcqRaHlSF3VSubPiEQFKKVc=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Distributed queries for pgvector"><meta name=twitter:description content="How to run distributed pgvector queries using PostgreSQL partitioning and postgres_fdw on your vector data."><meta property="og:url" content="https://jkatz.github.io/post/postgres/distributed-pgvector/"><meta property="og:site_name" content="Jonathan Katz"><meta property="og:title" content="Distributed queries for pgvector"><meta property="og:description" content="How to run distributed pgvector queries using PostgreSQL partitioning and postgres_fdw on your vector data."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-03-18T00:00:00+00:00"><meta property="article:modified_time" content="2024-03-18T00:00:00+00:00"><meta property="article:tag" content="Postgres"><meta property="article:tag" content="Postgresql"><meta property="article:tag" content="Pgvector"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"post","name":"Distributed queries for pgvector","headline":"Distributed queries for pgvector","alternativeHeadline":"","description":"
      How to run distributed pgvector queries using PostgreSQL partitioning and postgres_fdw on your vector data.


    ","inLanguage":"en","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/jkatz.github.io\/post\/postgres\/distributed-pgvector\/"},"author":{"@type":"Person","name":"Jonathan Katz"},"creator":{"@type":"Person","name":"Jonathan Katz"},"accountablePerson":{"@type":"Person","name":"Jonathan Katz"},"copyrightHolder":{"@type":"Person","name":"Jonathan Katz"},"copyrightYear":"2024","dateCreated":"2024-03-18T00:00:00.00Z","datePublished":"2024-03-18T00:00:00.00Z","dateModified":"2024-03-18T00:00:00.00Z","publisher":{"@type":"Organization","name":"Jonathan Katz","url":"https://jkatz.github.io/","logo":{"@type":"ImageObject","url":"https:\/\/jkatz.github.io\/favicons\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/jkatz.github.io\/post\/postgres\/distributed-pgvector\/","wordCount":"2962","genre":[],"keywords":["postgres","postgresql","pgvector"]}</script></head><body class=body><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/images/profile.png alt="profile picture"><div class=sidebar__introduction-title><a href=/>Jonathan Katz</a></div><div class=sidebar__introduction-description><p></p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://bsky.app/profile/jkatz05.com target=_blank rel="noopener me" aria-label=Bluesky title=Bluesky><i class="fab fa-bluesky fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://www.linkedin.com/in/jonathan-katz-6495532/ target=_blank rel="noopener me" aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://www.twitter.com/jkatz05 target=_blank rel="noopener me" aria-label=Twitter title=Twitter><i class="fab fa-x-twitter fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/jkatz/ target=_blank rel="noopener me" aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=mailto:jkatz05@jkatz05.com target=_blank rel="noopener me" aria-label=e-mail title=e-mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
2024 Jonathan Katz</li><li class=footer__item><a class=link href=https://github.com/lxndrblz/anatole target=_blank rel="noopener noreferrer" title>Powered by the Anatole Hugo Theme</a></li><li class=footer__item><a class=link href title>Opinions are my own.</a></li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-NNLWC1035Y"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-NNLWC1035Y")</script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Home</a></li><li class=nav__list-item><a href=/post/ title>Posts</a></li><li class=nav__list-item><a href=/talks/ title>Talks</a></li><li class=nav__list-item><a href=/about/ title>About</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Distributed Queries for Pgvector</h1><ul class=post__meta><li class=post__meta-item><em class="fas fa-calendar-day post__meta-icon"></em>
<span class=post__meta-text>Mon, Mar 18, 2024</span></li><li class=post__meta-item><em class="fas fa-stopwatch post__meta-icon"></em>
<span class=post__meta-text>14-minute read</span></li></ul><p>The past few releases of <a href=https://github.com/pgvector/pgvector>pgvector</a> have emphasized features that help to vertically scale, particularly around index build parallelism. Scaling vertically is convenient for many reasons, especially because it&rsquo;s simpler to continue managing data that&rsquo;s located within a single instance.</p><p>Performance of querying vector data tends to be memory-bound, meaning that the more vector data you can keep in memory, the faster your database will return queries. It&rsquo;s also completely acceptable to not have your entire vector workload contained within memory, as long as you&rsquo;re meeting your latency requirements.</p><p>However, they may be a point that you can&rsquo;t vertically scale any further, such as not having an instance large enough to keep your entire vector dataset in memory. However, there may be a way to combine <a href=https://www.postgresql.org>PostgreSQL</a> features with pgvector to create a multi-node system to run distributed, performant queries across multiple instances.</p><p>To see how this works, we&rsquo;ll need to explore several features in PostgreSQL that help with segmenting and distributing data, including <a href=https://www.postgresql.org/docs/current/ddl-partitioning.html>partitioning</a> and <a href=https://www.postgresql.org/docs/current/ddl-foreign-data.html>foreign data wrappers</a>. We&rsquo;ll see how we can use these features to run distributed queries with pgvector, and explore the &ldquo;can we&rdquo; / &ldquo;should we&rdquo; questions.</p><h2 id=partitioning-and-pgvector>Partitioning and pgvector</h2><p>Partitioning is a general database technique that lets you divide data in a single table over multiple tables, and is used for purposes such as archiving, segmenting by time, and reducing the overall portion of a data set that you need to search over. PostgreSQL supports three types of partitioning: <a href=https://www.postgresql.org/docs/current/ddl-partitioning.html#DDL-PARTITIONING-OVERVIEW-RANGE>range</a>, <a href=https://www.postgresql.org/docs/current/ddl-partitioning.html#DDL-PARTITIONING-OVERVIEW-LIST>list</a>, and <a href=https://www.postgresql.org/docs/current/ddl-partitioning.html#DDL-PARTITIONING-OVERVIEW-HASH>hash</a>. You use list and range partitioning when you have a defined partition key (e.g. <code>company_id</code> or <code>start_date BETWEEN '2024-03-01' AND '2024-03-31</code>), whereas you use hash partitioning when you want to evenly distribute your data across partitions.</p><p>There are many considerations you must make before adopting a partitioning strategy, including understanding how your application will interact with your partitioned table and your partition management strategy. You also want to ensure you don&rsquo;t create &ldquo;too many partitions,&rdquo; which is an upper bound that&rsquo;s increased over the past several PostgreSQL releases (1000s is acceptable, depending on strategy).</p><p><a href="https://github.com/pgvector/pgvector/?tab=readme-ov-file#filtering">pgvector works natively with PostgreSQL partitioning</a>. Based upon the structure of your data and query patterns, you may choose to partition your data and build individual indexes over each partition as a way to enable &ldquo;prefiltering&rdquo; (your <code>WHERE</code> clause) of your queries, for example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>documents</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=nb>int</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>category_id</span><span class=w> </span><span class=nb>int</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>embedding</span><span class=w> </span><span class=n>vector</span><span class=p>(</span><span class=mi>1536</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=n>PARTITION</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>HASH</span><span class=p>(</span><span class=n>category_id</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>documents_0</span><span class=w> </span><span class=n>PARTITION</span><span class=w> </span><span class=k>OF</span><span class=w> </span><span class=n>documents</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>FOR</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=k>WITH</span><span class=w> </span><span class=p>(</span><span class=n>MODULUS</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=n>REMAINDER</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>documents_1</span><span class=w> </span><span class=n>PARTITION</span><span class=w> </span><span class=k>OF</span><span class=w> </span><span class=n>documents</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>FOR</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=k>WITH</span><span class=w> </span><span class=p>(</span><span class=n>MODULUS</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=n>REMAINDER</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- recursively creates an index on each partition
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>documents</span><span class=w> </span><span class=k>USING</span><span class=w> </span><span class=n>hnsw</span><span class=p>(</span><span class=n>embeddings</span><span class=w> </span><span class=n>vector_cosine_ops</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>However, the above example also shows one of the challenges with partitioning if you&rsquo;re searching over a partition with either mixed data in your filter, or with multiple filters. Based on your search parameter value (<code>hnsw.ef_search</code> or <code>ivfflat.probes</code>), you may not return enough results from the index that match all of the filters. You can remedy this by increasing the values of <code>hnsw.ef_search</code> or <code>ivfflat.probes</code>; as of this writing, there is also work going into pgvector to add more prefiltering options.</p><p>Now that we&rsquo;ve had a brief overview of partitioning, let&rsquo;s look at foreign data wrappers.</p><h2 id=foreign-data-wrappers-and-postgres_fdw>Foreign data wrappers and <code>postgres_fdw</code></h2><p><a href=https://wiki.postgresql.org/wiki/Foreign_data_wrappers>Foreign data wrappers</a> (<a href=https://wiki.postgresql.org/wiki/Foreign_data_wrappers>FDWs</a>), part of the <a href=https://wiki.postgresql.org/wiki/SQL/MED>SQL/MED</a> standard, let you work with remote data sources from SQL. PostgreSQL has <a href=https://wiki.postgresql.org/wiki/Foreign_data_wrappers>many different FDWs</a>, from the built-in <a href=https://www.postgresql.org/docs/current/postgres-fdw.html><code>postgres_fdw</code></a>, to others that can read/write to other databases or remote sources. Foreign data wrappers are used to run federated queries (queries across instances), push data into remote systems, and can be used to migrate data to PostgreSQL.</p><p>The <code>postgres_fdw</code> lets you work with data across PostgreSQL databases. Since it&rsquo;s introduction in <a href=https://www.postgresql.org/docs/release/9.3.0/>PostgreSQL 9.3</a>, the <code>postgres_fdw</code> has added features to make it possible to run distributed workloads, including different query pushdowns (executing queries on remote instances), convenience functions for loading remote schemas, and running queries asynchronous across remote instances. While the <code>postgres_fdw</code> is a good solution for certain types of data federation, but is not yet a full solution for sharding, as sharding requires additional data management techniques (e.g., node management / rebalancing).</p><p>Using the <code>postgres_fdw</code> in production requires security considerations, including authentication/authorization managemet, including on both the local and remote servers, and network management. I won&rsquo;t be getting into these techniques here, but if you decide you want to use this in production, you&rsquo;ll want to follow security best practices. At <a href=https://2015.pgconf.eu/>PGConf EU 2015</a>, I gave a presentation on <a href=https://www.slideshare.net/jkatz05/developing-and-deploying-apps-with-the-postgres-fdw>lessons learned deploying the <code>postgres_fdw</code> in production</a>; most of those lessons still apply!</p><p>With partitioning and FDWs, we now have the tools to run distributed pgvector queries!</p><h2 id=distributed-queries-for-pgvector>Distributed queries for pgvector</h2><p>We can combine partitioning and the <code>postgres_fdw</code> to run pgvector queries across multiple instances. For this experiment, I set up 3 instances:</p><ul><li>Two r7gd.4xlarge (16 vCPU, 128GB RAM) instances. These are called <code>node1</code> and <code>node2</code> in this post.</li><li>One &ldquo;head node&rdquo; that sends the data to the different systems, which I&rsquo;ll refer to as <code>head</code>. I used a smaller instance here, as most of the work is handled by <code>node1</code> / <code>node2</code>.</li></ul><p>Additionally, to reduce latency, I kept all of these instances within the same availability zone, and I used the local disk (NVMe) for storage on <code>node1</code> and <code>node2</code>.</p><p>On <code>node1</code> and <code>node2</code>, I used the following applicable <code>postgresql.conf</code> configuration parameters:</p><ul><li><code>effective_cache_size</code>: 64GB</li><li><code>maintenance_work_mem</code>: 32GB</li><li><code>max_parallel_maintenance_workers</code>: 15</li><li><code>max_parallel_workers</code>: 16</li><li><code>max_parallel_workers_per_gather</code>: 16</li><li><code>max_worker_processes</code>: 32</li><li><code>shared_buffers</code>: 32GB</li><li><code>work_mem</code>: 64MB</li></ul><p>For all the tests, I used <a href=https://github.com/pgvector/pgvector/commit/0d35a141>pgvector@0d35a141</a>, which is a few commits off from the code in the v0.6.2 release.</p><p>I ran two tests:</p><ol><li>&ldquo;Can we&rdquo;: determine if this method is even feasible.</li><li>&ldquo;Should we&rdquo;: demonstrate how federation technique <a href=/post/postgres/pgvector-hnsw-performance/>impacts recall and query performance</a> using <a href=https://github.com/erikbern/ann-benchmarks>ANN Benchmarks</a>.</li></ol><h3 id=test-1-can-we---feasibility-of-pgvector-distributed-queries>Test 1: &ldquo;Can we&rdquo; - feasibility of pgvector distributed queries</h3><p>First, we need to set up the schema on each node. For this test, I ran the following commands on <code>node1</code> and <code>node2</code> in a database called <code>vectors</code> with a user called <code>distpgv</code> that has create permissions in that database:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=n>EXTENSION</span><span class=w> </span><span class=k>IF</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=n>vector</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>vectors</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=n>uuid</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>gen_random_uuid</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>node_id</span><span class=w> </span><span class=nb>int</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=c1>-- change to 2 on node 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>embedding</span><span class=w> </span><span class=n>vector</span><span class=p>(</span><span class=mi>768</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>vectors</span><span class=w> </span><span class=k>ALTER</span><span class=w> </span><span class=k>COLUMN</span><span class=w> </span><span class=n>embedding</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=k>STORAGE</span><span class=w> </span><span class=n>PLAIN</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>The following function is used to generate synthetic data:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=k>REPLACE</span><span class=w> </span><span class=k>FUNCTION</span><span class=w> </span><span class=k>public</span><span class=p>.</span><span class=n>generate_random_normalized_vector</span><span class=p>(</span><span class=n>dim</span><span class=w> </span><span class=nb>integer</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>RETURNS</span><span class=w> </span><span class=n>vector</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>LANGUAGE</span><span class=w> </span><span class=n>plpgsql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>AS</span><span class=w> </span><span class=err>$</span><span class=k>function</span><span class=err>$</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>DECLARE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>a</span><span class=w> </span><span class=nb>real</span><span class=p>[];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>mag</span><span class=w> </span><span class=nb>real</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>x</span><span class=w> </span><span class=nb>real</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>i</span><span class=w> </span><span class=nb>int</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>BEGIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>SELECT</span><span class=w> </span><span class=n>array_agg</span><span class=p>(</span><span class=n>random</span><span class=p>()::</span><span class=nb>real</span><span class=p>)</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>a</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=n>generate_series</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=n>dim</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>mag</span><span class=w> </span><span class=p>:</span><span class=o>=</span><span class=w> </span><span class=k>public</span><span class=p>.</span><span class=n>vector_norm</span><span class=p>(</span><span class=n>a</span><span class=p>::</span><span class=n>vector</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>FOR</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=mi>1</span><span class=p>..</span><span class=n>dim</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>LOOP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w> </span><span class=p>:</span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>mag</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>END</span><span class=w> </span><span class=n>LOOP</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>RETURN</span><span class=w> </span><span class=n>a</span><span class=p>::</span><span class=n>vector</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>END</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>$</span><span class=k>function</span><span class=err>$</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>For this test, I ran the following on each instance to insert 5MM rows (2.5MM on each instance):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>vectors</span><span class=w> </span><span class=p>(</span><span class=n>embedding</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>generate_random_normalized_vector</span><span class=p>(</span><span class=mi>768</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>generate_series</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=n>_500_000</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>Once the inserts were completed, I ran the following to build the index (adjust <code>max_parallel_maintenance_workers</code> to the available cores on your environment):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=n>max_parallel_maintenance_workers</span><span class=w> </span><span class=k>TO</span><span class=w> </span><span class=mi>16</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>vectors</span><span class=w> </span><span class=k>USING</span><span class=w> </span><span class=n>hnsw</span><span class=p>(</span><span class=n>embedding</span><span class=w> </span><span class=n>vector_cosine_ops</span><span class=p>)</span><span class=w> </span><span class=k>WITH</span><span class=w> </span><span class=p>(</span><span class=n>ef_construction</span><span class=o>=</span><span class=mi>256</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>With this, the data is now set up on each of the nodes. Back on the <code>head</code> instance, we need to set up the FDW and connections to the instances.</p><p>On <code>head</code>, first install pgvector and the <code>postgres_fdw</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=n>EXTENSION</span><span class=w> </span><span class=k>IF</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=n>vector</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=n>EXTENSION</span><span class=w> </span><span class=k>IF</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=n>postgres_fdw</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>The next set of SQL is the key bit that will allow us to run distributed pgvector queries. You&rsquo;ll create two &ldquo;servers,&rdquo; which will tell PostgreSQL where your remote nodes are, and what their capabilities are:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=n>SERVER</span><span class=w> </span><span class=n>vectors1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>FOREIGN</span><span class=w> </span><span class=k>DATA</span><span class=w> </span><span class=n>WRAPPER</span><span class=w> </span><span class=n>postgres_fdw</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>OPTIONS</span><span class=w> </span><span class=p>(</span><span class=n>async_capable</span><span class=w> </span><span class=s1>&#39;true&#39;</span><span class=p>,</span><span class=w> </span><span class=n>extensions</span><span class=w> </span><span class=s1>&#39;vector&#39;</span><span class=p>,</span><span class=w> </span><span class=n>dbname</span><span class=w> </span><span class=s1>&#39;vectors&#39;</span><span class=p>,</span><span class=w> </span><span class=k>host</span><span class=w> </span><span class=s1>&#39;&lt;NODE1&gt;&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=n>SERVER</span><span class=w> </span><span class=n>vectors2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>FOREIGN</span><span class=w> </span><span class=k>DATA</span><span class=w> </span><span class=n>WRAPPER</span><span class=w> </span><span class=n>postgres_fdw</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>OPTIONS</span><span class=w> </span><span class=p>(</span><span class=n>async_capable</span><span class=w> </span><span class=s1>&#39;true&#39;</span><span class=p>,</span><span class=w> </span><span class=n>extensions</span><span class=w> </span><span class=s1>&#39;vector&#39;</span><span class=p>,</span><span class=w> </span><span class=n>dbname</span><span class=w> </span><span class=s1>&#39;vectors&#39;</span><span class=p>,</span><span class=w> </span><span class=k>host</span><span class=w> </span><span class=s1>&#39;&lt;NODE2&gt;&#39;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>Aside from the connection parameters, there are two key options to know:</p><ul><li><code>async_capable</code>: This means that the remote server is capable of executing queries asynchronously. This lets us simultaneously execute pgvector queries on each node, instead of executing them one-at-a-time (serially).</li><li><code>extensions</code>: This indicates what extensions are available on the remote server. This allows us to pushdown the pgvector index lookups to the remote nodes.</li></ul><p>Next, we need to add connection information for how a local PostgreSQL user will connect to the remote instances. Substitute <code>local_user</code> for the user you create on your local instance:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>USER</span><span class=w> </span><span class=n>MAPPING</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=n>local_user</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>SERVER</span><span class=w> </span><span class=n>vectors1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>OPTIONS</span><span class=w> </span><span class=p>(</span><span class=k>user</span><span class=w> </span><span class=s1>&#39;pgvdist&#39;</span><span class=p>,</span><span class=w> </span><span class=n>password</span><span class=w> </span><span class=s1>&#39;&lt;SECUREPASSWORD&gt;&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>USER</span><span class=w> </span><span class=n>MAPPING</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=n>local_user</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>SERVER</span><span class=w> </span><span class=n>vectors2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>OPTIONS</span><span class=w> </span><span class=p>(</span><span class=k>user</span><span class=w> </span><span class=s1>&#39;pgvdist&#39;</span><span class=p>,</span><span class=w> </span><span class=n>password</span><span class=w> </span><span class=s1>&#39;&lt;SECUREPASSWORD&gt;&#39;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>Finally, we&rsquo;ll create a partitioned table, where each partition is a &ldquo;<a href=https://www.postgresql.org/docs/current/ddl-foreign-data.html>foreign table</a>,&rdquo; or a reference to a table located on the remote server.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>vectors</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=n>uuid</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>node_id</span><span class=w> </span><span class=nb>int</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>embedding</span><span class=w> </span><span class=n>vector</span><span class=p>(</span><span class=mi>768</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>PARTITION</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>LIST</span><span class=p>(</span><span class=n>node_id</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- reference to the table on node 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>FOREIGN</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>vectors_node1</span><span class=w> </span><span class=n>PARTITION</span><span class=w> </span><span class=k>OF</span><span class=w> </span><span class=n>vectors</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>FOR</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>SERVER</span><span class=w> </span><span class=n>vectors1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>OPTIONS</span><span class=w> </span><span class=p>(</span><span class=k>schema_name</span><span class=w> </span><span class=s1>&#39;public&#39;</span><span class=p>,</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=s1>&#39;vectors&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- reference to the table on node 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>FOREIGN</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>vectors_node2</span><span class=w> </span><span class=n>PARTITION</span><span class=w> </span><span class=k>OF</span><span class=w> </span><span class=n>vectors</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>FOR</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=mi>2</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>SERVER</span><span class=w> </span><span class=n>vectors2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>OPTIONS</span><span class=w> </span><span class=p>(</span><span class=k>schema_name</span><span class=w> </span><span class=s1>&#39;public&#39;</span><span class=p>,</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=s1>&#39;vectors&#39;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>Let&rsquo;s test to see that we can query the remote tables. Below is an example of the output from an explain plan that counts all the rows across each node:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>vectors</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>yields:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> Aggregate  (cost=2687700.00..2687700.01 rows=1 width=8)
</span></span><span class=line><span class=cl>   -&gt;  Append  (cost=100.00..2675200.00 rows=5000000 width=0)
</span></span><span class=line><span class=cl>         -&gt;  Async Foreign Scan on vectors_node1 vectors_1  (cost=100.00..1325100.00 rows=2500000 width=0)
</span></span><span class=line><span class=cl>         -&gt;  Async Foreign Scan on vectors_node2 vectors_2  (cost=100.00..1325100.00 rows=2500000 width=0)
</span></span></code></pre></div><p>We can see that the PostgreSQL query planner will attempt to perform an &ldquo;async foreign scan,&rdquo; which means it will run each query asynchronously on the individual nodes, and then determine the final results on the head node. When I used <code>EXPLAIN ANALYZE</code>, I received the following output that showed the asynchronous execution:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> Aggregate  (cost=2687700.00..2687700.01 rows=1 width=8) (actual time=5755.761..5755.762 rows=1 loops=1)
</span></span><span class=line><span class=cl>   -&gt;  Append  (cost=100.00..2675200.00 rows=5000000 width=0) (actual time=0.603..5415.869 rows=5000000 loops=1)
</span></span><span class=line><span class=cl>         -&gt;  Async Foreign Scan on vectors_node1 vectors_1  (cost=100.00..1325100.00 rows=2500000 width=0) (actual time=0.319..1192.879 rows=2500000 loops=1)
</span></span><span class=line><span class=cl>         -&gt;  Async Foreign Scan on vectors_node2 vectors_2  (cost=100.00..1325100.00 rows=2500000 width=0) (actual time=0.303..1140.443 rows=2500000 loops=1)
</span></span><span class=line><span class=cl> Planning Time: 0.169 ms
</span></span><span class=line><span class=cl> Execution Time: 5756.769 ms
</span></span></code></pre></div><p>Now for the big test: running a distributed / federated query for pgvector. First, let&rsquo;s create some test data. I ran this command using <code>psql</code> to store the query vector in a session variable called <code>v</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>generate_random_normalized_vector</span><span class=p>(</span><span class=mi>768</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=err>\</span><span class=n>gset</span><span class=w>
</span></span></span></code></pre></div><p>I ran the following query to find the 10 nearest neighbors across all the nodes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>node_id</span><span class=p>,</span><span class=w> </span><span class=p>:</span><span class=s1>&#39;v&#39;</span><span class=w> </span><span class=o>&lt;=&gt;</span><span class=w> </span><span class=n>embedding</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>distance</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>vectors</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>distance</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>LIMIT</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>which yielded:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                  id                  | node_id |      distance       
</span></span><span class=line><span class=cl>--------------------------------------+---------+---------------------
</span></span><span class=line><span class=cl> 9a88e75f-4a03-4964-9435-f6596087db7f |       2 | 0.20965892220421145
</span></span><span class=line><span class=cl> 251fe736-e06b-4a30-ad98-10132fd04db6 |       2 | 0.20981185523973567
</span></span><span class=line><span class=cl> 3d024d54-b01e-468a-9e3b-d0d63a46c599 |       2 | 0.21044588244644724
</span></span><span class=line><span class=cl> d03cd294-d6dc-4074-a614-a2514a64a035 |       1 |  0.2111870772354053
</span></span><span class=line><span class=cl> 9e5db921-c4f7-4bb8-b840-81d1c5fd4d02 |       2 | 0.21178618704635432
</span></span><span class=line><span class=cl> c6edadd6-c5d6-4fd3-9f15-8c6b67e01986 |       2 |   0.212410164619098
</span></span><span class=line><span class=cl> bc1822aa-3cfd-4614-8a87-d93909e00e49 |       2 |  0.2132984165340187
</span></span><span class=line><span class=cl> 1563e694-c84e-4ed3-9285-e0f33e5717c5 |       1 | 0.21351215879655328
</span></span><span class=line><span class=cl> c5616138-629b-4dac-97be-8da2a031593c |       1 | 0.21449695955189663
</span></span><span class=line><span class=cl> 6056e8f5-c52a-4f4d-8ca5-3c160d6116d3 |       2 | 0.21495852514977798
</span></span></code></pre></div><p>with the following execution plan:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Limit  (cost=200.01..206.45 rows=10 width=28) (actual time=18.171..18.182 rows=10 loops=1)
</span></span><span class=line><span class=cl>   -&gt;  Merge Append  (cost=200.01..3222700.01 rows=5000000 width=28) (actual time=18.169..18.179 rows=10 loops=1)
</span></span><span class=line><span class=cl>         Sort Key: ((&#39;$1&#39;::vector &lt;=&gt; vectors.embedding))
</span></span><span class=line><span class=cl>         -&gt;  Foreign Scan on vectors_node1 vectors_1  (cost=100.00..1586350.00 rows=2500000 width=28) (actual time=8.607..8.609 rows=2 loops=1)
</span></span><span class=line><span class=cl>         -&gt;  Foreign Scan on vectors_node2 vectors_2  (cost=100.00..1586350.00 rows=2500000 width=28) (actual time=9.559..9.566 rows=9 loops=1)
</span></span><span class=line><span class=cl> Planning Time: 0.298 ms
</span></span><span class=line><span class=cl> Execution Time: 19.355 ms
</span></span></code></pre></div><p>Success! We can see that we were able to run the distributed query and get the most similarity vectors regardless of node they were on. Based on the timings, we also see that used the HNSW indexes that were available on each instance.</p><p>However, on closer inspection, we can see that we didn&rsquo;t perform an async foreign scan, but executed each statement serially. Currently (based on my read of the PostgreSQL docs and code), PostgreSQL does not support async foreign scans with a &ldquo;Merge Append&rdquo; node (e.g., running multiple operations that require merging sort results, such as a K-NN sort). This may not matter if you don&rsquo;t have many nodes, but could factor into larger, distributed data sets.</p><p>Now that we&rsquo;ve answered &ldquo;could we,&rdquo; let&rsquo;s look at one aspect of &ldquo;should we&rdquo; and measure recall across a distributed data set.</p><h2 id=test-2-should-we---ann-benchmarks-using-distributed-queries-for-pgvector>Test 2: &ldquo;Should we&rdquo; - ANN Benchmarks using distributed queries for pgvector</h2><p>For the next test, we&rsquo;ll see how using this federation technique impacts recall and query performance. We want to test recall to ensure that distributing the data does not cause a regression in the quality of the results. Understanding query performance can help provide guidance on if/when we want to use this technique at all. I specifically did not test other aspects of vector storage (e.g., index size) as this was less of a factor in the differences in the environments tested in this example.</p><p>In this experiment, we&rsquo;ll compare the 2-node federated setup in the previous example to a single instance (1-node, using a r7g.4xlarge) set up. I had to make a few modifications to the pgvector test in <a href=https://github.com/erikbern/ann-benchmarks>ANN Benchmarks</a> to support distributed queries, specifically:</p><ul><li>Supporting creating tables and indexes on individual nodes (in this case, <code>node1</code> and <code>node2</code>)</li><li>Push setting <code>hnsw.ef_search</code> down to individual nodes. As there isn&rsquo;t a way to federate the values of session variables from <code>head</code> to <code>node1</code> and <code>node2</code> (or if there is, I didn&rsquo;t figure it out), I explicitly set the values using <a href=https://www.postgresql.org/docs/current/sql-altersystem.html><code>ALTER SYSTEM</code></a> and <code>pg_reload_conf()</code>.</li><li>On the <code>head</code> node, I created a partitioned table with a hash partitioning method with references to the remote nodes:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>items</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=nb>int</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>embedding</span><span class=w> </span><span class=n>vector</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=n>PARTITION</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>HASH</span><span class=p>(</span><span class=n>id</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- reference to the table on node 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>FOREIGN</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>items_node1</span><span class=w> </span><span class=n>PARTITION</span><span class=w> </span><span class=k>OF</span><span class=w> </span><span class=n>items</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>FOR</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=k>WITH</span><span class=w> </span><span class=p>(</span><span class=n>MODULUS</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=n>REMAINDER</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>SERVER</span><span class=w> </span><span class=n>vectors1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>OPTIONS</span><span class=w> </span><span class=p>(</span><span class=k>schema_name</span><span class=w> </span><span class=s1>&#39;public&#39;</span><span class=p>,</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=s1>&#39;items&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- reference to the table on node 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>FOREIGN</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>items_node2</span><span class=w> </span><span class=n>PARTITION</span><span class=w> </span><span class=k>OF</span><span class=w> </span><span class=n>items</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>FOR</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=k>WITH</span><span class=w> </span><span class=p>(</span><span class=n>MODULUS</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=n>REMAINDER</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>SERVER</span><span class=w> </span><span class=n>vectors2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>OPTIONS</span><span class=w> </span><span class=p>(</span><span class=k>schema_name</span><span class=w> </span><span class=s1>&#39;public&#39;</span><span class=p>,</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=s1>&#39;items&#39;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>For all tests, I used the following build parameters:</p><ul><li><code>m</code>: 16</li><li><code>ef_construction</code>: 256</li></ul><p>Below are the results from three different datasets available in ANN Benchmarks (for my thoughts on these datasets, <a href=/post/postgres/pgvector-hnsw-performance/>please see this blog post</a>), followed by analysis:</p><ul><li><code>sift-128-euclidean</code> (1MM, 128-dim)</li><li><code>dbpedia-openai-1000k-angular</code> (1MM, 1536-dim)</li><li><code>gist-960-euclidean</code> (1MM, 960-dim)</li></ul><p>Recall is measured from 0 to 1 (0% to 100% relevant results returned). Queries per second (QPS) is measured in how many queries complete per second :)</p><h4 id=sift-128-euclidean>sift-128-euclidean</h4><p><img alt=pgvector-distributed-sift128-recall.png src=/images/pgvector-distributed-sift128-recall.png></p><table><thead><tr><th><code>ef_search</code></th><th>Recall (1-node)</th><th>Recall (2-node)</th></tr></thead><tbody><tr><td>10</td><td>0.776</td><td>0.833</td></tr><tr><td>20</td><td>0.884</td><td>0.922</td></tr><tr><td>40</td><td>0.953</td><td>0.973</td></tr><tr><td>80</td><td>0.986</td><td>0.994</td></tr><tr><td>120</td><td>0.994</td><td>0.998</td></tr><tr><td>200</td><td>0.998</td><td>0.999</td></tr><tr><td>400</td><td>1.000</td><td>1.000</td></tr><tr><td>800</td><td>1.000</td><td>1.000</td></tr></tbody></table><p><img alt=pgvector-distributed-sift128-qps.png src=/images/pgvector-distributed-sift128-qps.png></p><table><thead><tr><th><code>ef_search</code></th><th>QPS (1-node)</th><th>QPS (2-node)</th></tr></thead><tbody><tr><td>10</td><td>2111</td><td>338</td></tr><tr><td>20</td><td>1536</td><td>272</td></tr><tr><td>40</td><td>1031</td><td>206</td></tr><tr><td>80</td><td>644</td><td>137</td></tr><tr><td>120</td><td>474</td><td>109</td></tr><tr><td>200</td><td>276</td><td>84</td></tr><tr><td>400</td><td>157</td><td>59</td></tr><tr><td>800</td><td>86</td><td>36</td></tr></tbody></table><h4 id=dbpedia-openai-1000k-angular>dbpedia-openai-1000k-angular</h4><p><img alt=pgvector-distributed-dbpedia1000k-recall.png src=/images/pgvector-distributed-dbpedia1000k-recall.png></p><table><thead><tr><th><code>ef_search</code></th><th>Recall (1-node)</th><th>Recall (2-node)</th></tr></thead><tbody><tr><td>10</td><td>0.852</td><td>0.885</td></tr><tr><td>20</td><td>0.927</td><td>0.945</td></tr><tr><td>40</td><td>0.968</td><td>0.977</td></tr><tr><td>80</td><td>0.987</td><td>0.991</td></tr><tr><td>120</td><td>0.992</td><td>0.995</td></tr><tr><td>200</td><td>0.996</td><td>0.997</td></tr><tr><td>400</td><td>0.998</td><td>0.999</td></tr><tr><td>800</td><td>0.999</td><td>0.999</td></tr></tbody></table><p><img alt=pgvector-distributed-dbpedia1000k-qps.png src=/images/pgvector-distributed-dbpedia1000k-qps.png></p><table><thead><tr><th><code>ef_search</code></th><th>QPS (1-node)</th><th>QPS (2-node)</th></tr></thead><tbody><tr><td>10</td><td>1131</td><td>89</td></tr><tr><td>20</td><td>853</td><td>55</td></tr><tr><td>40</td><td>550</td><td>31</td></tr><tr><td>80</td><td>342</td><td>17</td></tr><tr><td>120</td><td>251</td><td>13</td></tr><tr><td>200</td><td>163</td><td>13</td></tr><tr><td>400</td><td>93</td><td>11</td></tr><tr><td>800</td><td>52</td><td>9</td></tr></tbody></table><h4 id=gist-960-euclidean>gist-960-euclidean</h4><p><img alt=pgvector-distributed-gist960-recall.png src=/images/pgvector-distributed-gist960-recall.png></p><table><thead><tr><th><code>ef_search</code></th><th>Recall (1-node)</th><th>Recall (2-node)</th></tr></thead><tbody><tr><td>10</td><td>0.509</td><td>0.584</td></tr><tr><td>20</td><td>0.652</td><td>0.733</td></tr><tr><td>40</td><td>0.783</td><td>0.852</td></tr><tr><td>80</td><td>0.883</td><td>0.932</td></tr><tr><td>120</td><td>0.925</td><td>0.962</td></tr><tr><td>200</td><td>0.960</td><td>0.981</td></tr><tr><td>400</td><td>0.987</td><td>0.995</td></tr><tr><td>800</td><td>0.995</td><td>0.998</td></tr></tbody></table><p><img alt=pgvector-distributed-gist960-qps.png src=/images/pgvector-distributed-gist960-qps.png></p><table><thead><tr><th><code>ef_search</code></th><th>QPS (1-node)</th><th>QPS (2-node)</th></tr></thead><tbody><tr><td>10</td><td>1107</td><td>134</td></tr><tr><td>20</td><td>782</td><td>89</td></tr><tr><td>40</td><td>509</td><td>54</td></tr><tr><td>80</td><td>302</td><td>30</td></tr><tr><td>120</td><td>218</td><td>24</td></tr><tr><td>200</td><td>144</td><td>21</td></tr><tr><td>400</td><td>81</td><td>17</td></tr><tr><td>800</td><td>45</td><td>13</td></tr></tbody></table><p>There are two interesting observations from these runs:</p><ul><li>At lower values of <code>hnsw.ef_search</code>, we observe an improvement in recall on the 2-node system up to 15%, which is not insignificant.</li><li>Overall we observe that QPS on the 1-node system is higher than the 2-node system. This is primarily due to network latency, though the serial execution of each foreign scan may impact (and will impact as the number of nodes in the system increase).</li></ul><p>From this, it&rsquo;d be easy to conclude that the distributed technique should not be used. However, the workload fit entirely into memory on the 1-node instance; if the 1-node was memory constrained and had to continuously fetch data from networked-attached storage, we would see different results.</p><p>Below I repeated the 1-node test, but I used the default PostgreSQL settings, including <code>128MB</code> for <code>shared_buffers</code>. This would memory constraint the system. I still used the local NVMe for storage. You can see the results of this test below:</p><h4 id=sift-128-euclidean-1>sift-128-euclidean</h4><table><thead><tr><th><code>ef_search</code></th><th>QPS (1-node; PG defaults)</th><th>QPS (2-node)</th></tr></thead><tbody><tr><td>10</td><td>1030</td><td>338</td></tr><tr><td>20</td><td>710</td><td>272</td></tr><tr><td>40</td><td>450</td><td>206</td></tr><tr><td>80</td><td>266</td><td>137</td></tr><tr><td>120</td><td>193</td><td>109</td></tr><tr><td>200</td><td>119</td><td>84</td></tr><tr><td>400</td><td>69</td><td>59</td></tr><tr><td>800</td><td>39</td><td>36</td></tr></tbody></table><h4 id=dbpedia-openai-1000k-angular-1>dbpedia-openai-1000k-angular</h4><table><thead><tr><th><code>ef_search</code></th><th>QPS (1-node; PG defaults)</th><th>QPS (2-node)</th></tr></thead><tbody><tr><td>10</td><td>731</td><td>89</td></tr><tr><td>20</td><td>510</td><td>55</td></tr><tr><td>40</td><td>323</td><td>31</td></tr><tr><td>80</td><td>192</td><td>17</td></tr><tr><td>120</td><td>141</td><td>13</td></tr><tr><td>200</td><td>93</td><td>13</td></tr><tr><td>400</td><td>53</td><td>11</td></tr><tr><td>800</td><td>30</td><td>9</td></tr></tbody></table><h4 id=gist-960-euclidean-1>gist-960-euclidean</h4><table><thead><tr><th><code>ef_search</code></th><th>QPS (1-node; PG defaults)</th><th>QPS (2-node)</th></tr></thead><tbody><tr><td>10</td><td>712</td><td>134</td></tr><tr><td>20</td><td>482</td><td>89</td></tr><tr><td>40</td><td>306</td><td>54</td></tr><tr><td>80</td><td>179</td><td>30</td></tr><tr><td>120</td><td>128</td><td>24</td></tr><tr><td>200</td><td>81</td><td>21</td></tr><tr><td>400</td><td>44</td><td>17</td></tr><tr><td>800</td><td>25</td><td>13</td></tr></tbody></table><p>Overall, while the 1-node test using the PostgreSQL defaults had higher QPS than the 2-node system, we see that the differences weren&rsquo;t as large once the workload was memory constrained &ndash; and in certain cases, the performance was comparable.</p><h2 id=conclusion>Conclusion</h2><p>Distributing a workload across multiple databases can be used to further scale a workload once you&rsquo;re unable to scale it past a single instance. pgvector builds on PostgreSQL features that help with scaling vertically, and recently pgvector releases <a href=https://aws.amazon.com/blogs/database/accelerate-hnsw-indexing-and-searching-with-pgvector-on-amazon-aurora-postgresql-compatible-edition-and-amazon-rds-for-postgresql/>have also shown that vector workloads can scale on PostgreSQL</a>.</p><p>While the experiments in this post show that it&rsquo;s possible to distribute pgvector workloads across multiple instances &ndash; and we can see benefits with recall &ndash; there&rsquo;s additional work that can simplify and help scale pgvector across multiple writable instances (e.g., pushdown session parameters, async execution across &ldquo;merge append&rdquo; nodes). If your workloads is read heavy, you can still use read replicas as a way to distribute traffic if your primary instance is saturated, but note that the entire data set is available on each instance.</p></div><div class=post__footer><span><a class=tag href=/tags/postgres/>postgres</a><a class=tag href=/tags/postgresql/>postgresql</a><a class=tag href=/tags/pgvector/>pgvector</a></span></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
2024 Jonathan Katz</li><li class=footer__item><a class=link href=https://github.com/lxndrblz/anatole target=_blank rel="noopener noreferrer" title>Powered by the Anatole Hugo Theme</a></li><li class=footer__item><a class=link href title>Opinions are my own.</a></li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-NNLWC1035Y"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-NNLWC1035Y")</script></body></html>